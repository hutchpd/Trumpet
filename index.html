<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Trumpet Trainer (MVP)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- TailwindCSS Play CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            brand: {
              50: '#eef8ff',
              100: '#d9eeff',
              200: '#b7dfff',
              300: '#87c8ff',
              400: '#51a9ff',
              500: '#2b8eff',
              600: '#1e73f0',
              700: '#205dd0',
              800: '#214da8',
              900: '#203f85'
            }
          }
        }
      }
    }
  </script>
  <!-- React 18 UMD + Babel for in-browser JSX -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Tone.js + @tonejs/midi (UMD) + VexFlow (UMD v3) -->
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
  <script src="https://unpkg.com/@tonejs/midi@2.0.27/build/Midi.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vexflow/3.0.9/vexflow-min.js"></script>
  <script>
    window.VF = (window.Vex && window.Vex.Flow) || window.VexFlow || window.vexflow || null;
  </script>

  <style>
    /* Minimal extras alongside Tailwind */
    :root {
      --bg: #0b1020;
      --fg: #d8e7ff;
      --laneA: #44e0a6;
      /* valve 1 */
      --laneB: #ffca3a;
      /* valve 2 */
      --laneC: #7cc6ff;
      /* valve 3 */
      --laneEdge: #143055;
      --grid: #0f2749;
      --hud: #6aa4ff;
    }

    html,
    body,
    #root {
      height: 100%;
    }

    body {
      margin: 0;
      color: var(--fg);
      background:
        radial-gradient(1200px 600px at 50% 8%, #0f1b36 10%, rgba(15, 27, 54, .6) 30%, transparent 60%),
        radial-gradient(circle at 50% 10%, #0f1b36, var(--bg) 60%);
      overflow: hidden;
    }

    /* Subtle screen vignette */
    .vignette {
      position: fixed;
      inset: 0;
      box-shadow: inset 0 0 160px 80px rgba(0, 0, 0, .6)
    }

    .hitline {
      position: absolute;
      left: 0;
      right: 0;
      border-top: 2px dashed rgba(255, 255, 255, 0.55);
      pointer-events: none;
    }

    .note-glow {
      filter:
        drop-shadow(0 0 6px rgba(148, 221, 255, 0.9)) drop-shadow(0 0 12px rgba(148, 221, 255, 0.6));
    }

    .scrollbar-thin::-webkit-scrollbar {
      height: 6px;
      width: 6px;
    }

    .scrollbar-thin::-webkit-scrollbar-thumb {
      background: #94a3b8;
      border-radius: 9999px;
    }

    .hud {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      background: linear-gradient(180deg, rgba(9, 14, 28, .7), rgba(9, 14, 28, .25));
      border-top: 1px solid rgba(255, 255, 255, .06);
      backdrop-filter: blur(6px);
      border-radius: 12px;
    }

    .pill {
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .06);
      border: 1px solid rgba(255, 255, 255, .12);
    }

    .kbd {
      display: inline-grid;
      place-items: center;
      width: 22px;
      height: 22px;
      border: 1px solid rgba(255, 255, 255, .25);
      border-radius: 6px;
      background: rgba(0, 0, 0, .25);
      font-size: 12px;
      font-weight: 600;
    }

    .vf-host svg path[fill="black"],
    .vf-host svg rect[fill="black"] {
      fill: #cbd5e1 !important;
      /* slate-300 */
    }

    .vf-host svg path[stroke="black"],
    .vf-host svg rect[stroke="black"] {
      stroke: #cbd5e1 !important;
      /* slate-300 */
    }

    .vf-host svg .vf-stave path {
      stroke: #94a3b8;
    }

    /* slate-400 */
    .vf-host svg .vf-barline path {
      stroke: #94a3b8;
    }


    svg .vf-clef *,
    svg .vf-clef_treble *,
    svg g[class*="clef"] *,
    svg .vf-timeSig *,
    svg .vf-timesig *,
    svg .vf-time-signature *,
    svg g[class*="timesig"] * {
      fill: #cbd5e1 !important;
      stroke: #cbd5e1 !important;
    }

    /* brighten the staff lines a touch so the whole staff pops */
    svg .vf-stave path {
      stroke: #94a3b8;
      /* slate-400 */
    }

    /* barlines */
    svg .vf-barline path {
      stroke: #94a3b8;
    }

    @property --pulse {
      syntax: '<number>';
      inherits: false;
      initial-value: 0;
    }


    .grid-drift {
      position: relative;
      overflow: hidden;
      isolation: isolate;
      --beat: .5s;
      --cell: 44px;
      --pulse: 0;
      --pulseAmp: 1;
      --scanAlpha: .25;
    }

    .grid-drift::before {
      content: "";
      position: absolute;
      inset: -10% -5% 10% -5%;
      z-index: 0;
      pointer-events: none;
      transform-origin: center bottom;
      transform:
        perspective(900px) rotateX(calc(58deg + 2deg * var(--pulse) * var(--pulseAmp))) translateY(calc(6% + 1% * var(--pulse) * var(--pulseAmp))) scaleY(calc(1 + 0.28 * var(--pulse) * var(--pulseAmp)));
      background-image:
        repeating-linear-gradient(to bottom,
          rgba(120, 220, 255, 0.45) 0 2px,
          transparent 2px var(--cell)),
        repeating-linear-gradient(to right,
          rgba(114, 166, 233, 0.25) 0 1px,
          transparent 1px var(--cell));
      background-size: 100% 100%, 100% 100%;
      /* tempo-locked drift: one vertical cell per beat; slow lateral shimmer */
      animation:
        gridDriftY calc(var(--beat) * 1) linear infinite,
        gridDriftX calc(var(--beat) * 8) linear infinite,
        gridBreath var(--beat) cubic-bezier(.2, .9, .2, 1) infinite;
      /* pulse also brightens slightly */
      opacity: calc(0.28 + 0.66 * clamp(var(--pulse), 0, 1));
      filter: brightness(calc(1 + 0.65 * var(--pulse) * var(--pulseAmp))) saturate(1.25);
      mix-blend-mode: screen;
      mask-image: linear-gradient(to bottom, transparent 0%, black 18%, black 70%, transparent 100%);
      -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 18%, black 70%, transparent 100%);
      will-change: background-position, transform, opacity;
    }

    .grid-drift::after {
      content: "";
      position: absolute;
      inset: 0;
      z-index: 0;
      pointer-events: none;
      background:
        radial-gradient(1200px 420px at 50% 2%,
          rgba(255, 190, 255, 0.18), rgba(255, 120, 220, 0.10) 40%,
          rgba(255, 0, 140, 0.06) 60%, transparent 70%),
        linear-gradient(to bottom, rgba(255, 40, 140, 0.25), transparent 28%);
      opacity: .95;
      mix-blend-mode: screen;
      mask-image: linear-gradient(to bottom, rgba(0, 0, 0, .0) 0%, rgba(0, 0, 0, 1) 12%, rgba(0, 0, 0, 1) 80%, rgba(0, 0, 0, .0) 100%);
    }

    @keyframes gridBreath {
      0% {
        --pulse: .05;
      }

      30% {
        --pulse: 1;
      }

      100% {
        --pulse: .05;
      }
    }

    .grid-drift>canvas {
      position: relative;
      z-index: 1;
    }

    @keyframes gridDriftY {
      from {
        background-position: 0 0, 0 0;
      }

      to {
        background-position: 0 var(--cell), 0 0;
      }
    }

    @keyframes gridDriftX {
      from {
        background-position: 0 0, 0 0;
      }

      to {
        background-position: 0 0, var(--cell) 0;
      }
    }
  </style>
</head>

<body class="text-slate-100 font-sans">
  <div id="root"></div>
  <div class="vignette pointer-events-none"></div>

  <script type="text/babel">

    const { useEffect, useRef, useState, useMemo, useCallback } = React;

    /******************************
     * Utilities
     ******************************/
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    // Valve bitmask helpers (1=valve1, 2=valve2, 4=valve3)
    const VALVE1 = 1, VALVE2 = 2, VALVE3 = 4;

    // Default key mapping
    const defaultKeyMap = { a: VALVE1, s: VALVE2, d: VALVE3 };

    const noteToMask = {
      'F#3': VALVE1 | VALVE2 | VALVE3, 'Gb3': VALVE1 | VALVE2 | VALVE3,
      'G3': VALVE1 | VALVE3,
      'G#3': VALVE2 | VALVE3, 'Ab3': VALVE2 | VALVE3,
      'A3': VALVE1 | VALVE2,
      'A#3': VALVE1, 'Bb3': VALVE1,
      'B3': VALVE2,
      'C4': 0,
      'C#4': VALVE1 | VALVE2, 'Db4': VALVE1 | VALVE2,
      'D4': VALVE1 | VALVE3,
      'D#4': VALVE2 | VALVE3, 'Eb4': VALVE2 | VALVE3,
      'E4': VALVE1 | VALVE2,
      'F4': VALVE1,
      'F#4': VALVE2, 'Gb4': VALVE2,
      'G4': 0,
      'G#4': VALVE2 | VALVE3, 'Ab4': VALVE2 | VALVE3,
      'A4': VALVE1 | VALVE2,
      'A#4': VALVE1, 'Bb4': VALVE1,
      'B4': VALVE2,
      'C5': 0,
      'C#5': VALVE1 | VALVE2, 'Db5': VALVE1 | VALVE2,
      'D5': VALVE1 | VALVE3,
      'D#5': VALVE2 | VALVE3, 'Eb5': VALVE2 | VALVE3,
      'E5': VALVE1 | VALVE2,
      'F5': VALVE1,
      'F#5': VALVE2, 'Gb5': VALVE2,
      'G5': 0,
      'G#5': VALVE2 | VALVE3, 'Ab5': VALVE2 | VALVE3,
      'A5': VALVE1 | VALVE2,
      'A#5': VALVE1, 'Bb5': VALVE1,
      'B5': VALVE2,
      'C6': 0,
      'C#6': VALVE1 | VALVE2, 'Db6': VALVE1 | VALVE2,
      'D6': VALVE1 | VALVE3
    };
    function noteNameToMask(name) {
      const m = /^([A-Ga-g])([b#]?)(-?\d+)$/.exec(name || "");
      if (!m) return null;
      const key = m[1].toUpperCase() + (m[2] || '') + m[3];
      return (key in noteToMask) ? noteToMask[key] : null;
    }

    // --- Highway color by pitch *range* (E3..D6 split into 4 bins) ---
    const COLOR_LOW = '#22c55e';  // green
    const COLOR_MID = '#eab308';  // yellow
    const COLOR_HI = '#f97316';  // orange
    const COLOR_TOP = '#ef4444';  // red
    const MIDI_MIN = 52;  // E3
    const MIDI_MAX = 86;  // D6
    function colorForMidi(m) {
      const t = clamp((m - MIDI_MIN) / (MIDI_MAX - MIDI_MIN), 0, 1);
      if (t < 0.25) return COLOR_LOW;
      if (t < 0.50) return COLOR_MID;
      if (t < 0.75) return COLOR_HI;
      return COLOR_TOP;
    }


    // MIDI <-> note helpers
    const midiToFreq = (m) => 440 * Math.pow(2, (m - 69) / 12);
    const freqToMidi = (f) => Math.round(69 + 12 * Math.log2(f / 440));

    function noteNameToMidi(name) {
      const m = /^([A-Ga-g])([b#]?)(-?\d+)$/.exec(name || "");
      if (!m) return null;
      const L = m[1].toUpperCase();
      const acc = m[2] || '';
      const oct = parseInt(m[3], 10);
      const base = { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 }[L];
      if (base === undefined) return null;
      let semi = base + (acc === '#' ? 1 : acc === 'b' ? -1 : 0);
      return (oct + 1) * 12 + semi;
    }
    function centsDiff(freqA, freqB) {
      if (freqA <= 0 || freqB <= 0) return Infinity;
      return 1200 * Math.log2(freqA / freqB);
    }


    // Duration quantiser: measure-beats -> VexFlow duration for a given denominator.
    function quantizeBeats(beats, den = 4) {
      // Beats contributed by each symbol within this time signature.
      const beatsOf = (vex, dots = 0) => {
        const base = { w: den / 1, h: den / 2, q: den / 4, 8: den / 8, 16: den / 16, 32: den / 32 }[vex] || (den / 4);
        return base * (dots ? 1.5 : 1);
      };
      const symbols = ['w', 'h', 'q', '8', '16', '32'];
      let best = { diff: Infinity, vex: 'q', dots: 0 };
      for (const s of symbols) {
        const b0 = beatsOf(s, 0);
        const d0 = Math.abs(beats - b0);
        if (d0 < best.diff) best = { diff: d0, vex: s, dots: 0 };
        const b1 = beatsOf(s, 1);
        const d1 = Math.abs(beats - b1);
        if (d1 < best.diff) best = { diff: d1, vex: s, dots: 1 };
      }
      return { vex: best.vex, dots: best.dots };
    }


    // Helpers for engraving fit
    function beatsOfVex(vex, dots, den) {
      const base = { w: den / 1, h: den / 2, q: den / 4, 8: den / 8, 16: den / 16, 32: den / 32 }[vex] || (den / 4);
      return base * (dots ? 1.5 : 1);
    }
    function shortenQuant(q) {
      if (q.dots) return { vex: q.vex, dots: 0 };
      const order = ['w', 'h', 'q', '8', '16', '32'];
      const i = order.indexOf(q.vex);
      if (i < 0 || i === order.length - 1) return null;
      return { vex: order[i + 1], dots: 0 };
    }


    function secondsPerBeat(bpm) { return 60 / bpm; }
    function secondsPerMeasure(bpm, tsNum = 4, tsDen = 4) {
      const beatSeconds = secondsPerBeat(bpm) * (4 / tsDen); // adjust for denominator
      return tsNum * beatSeconds;
    }

    // Build lane events (one per lane per note) for canvas from MIDI notes
    function buildLaneEvents(notes, bpm, maskFromName, visualLookahead = 3.5) {
      const events = [];
      for (const n of notes) {
        const mask = maskFromName(n.name);
        // Skip notes that are out of our Yamaha map (no draw, no scoring)
        if (mask === null || mask === undefined) continue;
        const noteColor = colorForMidi(n.midi ?? freqToMidi(n.freq || 440));
        const lanes = [VALVE1, VALVE2, VALVE3];
        for (let i = 0; i < lanes.length; i++) {
          const bit = lanes[i];
          if (mask & bit) {
            events.push({
              lane: i, // 0,1,2
              start: n.time,
              end: n.time + n.duration,
              startTicks: n.ticks || 0,
              endTicks: (n.ticks || 0) + (n.durationTicks || 0),
              hit: false,
              judged: false,
              // render cache
              color: noteColor,
            });
          }
        }
        // If mask == 0 (open)
        if (mask === 0) {
          events.push({
            lane: -1,                // special: not tied to a valve lane
            open: true,
            start: n.time,
            end: n.time + n.duration,
            startTicks: n.ticks || 0,
            endTicks: (n.ticks || 0) + (n.durationTicks || 0),
            hit: false,
            judged: false,
            color: noteColor
          });
        }

      }
      // Sort by start time
      events.sort((a, b) => a.start - b.start || a.lane - b.lane);
      return events;
    }

    /******************************
     * Audio / Transport
     ******************************/
    function useToneSetup() {
      const synthRef = useRef(null);
      const limiterRef = useRef(null);
      const partRef = useRef(null);
      const initedRef = useRef(false);
      const readyRef = useRef(false);

      const initAudio = useCallback(async () => {
        if (initedRef.current) return;
        await Tone.start();               // ensure user-gesture start
        // Build synth chain AFTER gesture to avoid autoplay warnings
        const synth = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: 'sawtooth' },
          envelope: { attack: 0.005, decay: 0.2, sustain: 0.15, release: 0.2 },
          volume: -8
        }).toDestination();
        const limiter = new Tone.Limiter(-6).toDestination();
        synth.connect(limiter);
        synthRef.current = synth;
        limiterRef.current = limiter;
        initedRef.current = true;
        readyRef.current = true;
      }, []);

      const schedulePart = useCallback(async (toneNotes, tickScale = 1) => {
        if (!toneNotes?.length) return;
        await initAudio();

        if (partRef.current) {
          try { partRef.current.dispose(); } catch { }
          partRef.current = null;
        }
        const synth = synthRef.current;
        const part = new Tone.Part((time, ev) => {
          if (ev.name && ev.duration) {
            synth.triggerAttackRelease(ev.name, ev.duration, time);
          } else if (ev.midi) {
            synth.triggerAttackRelease(midiToFreq(ev.midi), ev.duration, time);
          }
        }, toneNotes.map(n => ({
          // schedule in ticks (scaled from MIDI PPQ into Transport PPQ)
          time: Tone.Ticks((n.ticks || 0) * tickScale),
          name: n.name,
          duration: Tone.Ticks((n.durationTicks || 0) * tickScale),
          midi: n.midi
        })));
        part.loop = false;
        part.start(0);
        partRef.current = part;
      }, [initAudio]);

      useEffect(() => {
        return () => {
          try { partRef.current?.dispose(); } catch { }
          try { synthRef.current?.dispose(); limiterRef.current?.dispose(); } catch { }
        };
      }, []);

      return { schedulePart, initAudio, readyRef };

    }

    /******************************
     * VexFlow ScoreDisplay (scroll + seek + cursor)
     ******************************/
    function ScoreDisplay({
      notes,
      bpm,
      timeSig = [4, 4],
      ppq = 480,
      currentTicks,
      running,
      width,
      micEnabled, micNote, expertMode, toleranceCents = 35,
      height,
      measuresPerRow = 2,
      onSeekTicks
    }) {
      const scrollRef = React.useRef(null);     // scrollable viewport
      const hostRef = React.useRef(null);     // where VexFlow SVG mounts
      const overlayRef = React.useRef(null);     // absolute overlay for cursor
      const draggingRef = React.useRef(false);
      const dragStart = React.useRef({ y: 0, top: 0 });
      const lastMeasureRef = React.useRef(-1);    // (2) autoscroll per bar, not per row
      const noteElsRef = React.useRef([]);        // (3) cache note <g> elements for fast highlight

      // Pre-compute measures & ticks
      const measureData = React.useMemo(() => {
        const [num, den] = timeSig || [4, 4];
        const measures = new Map();
        const ticksToBeats = (ticks) => (ticks / (ppq || 480)) * (4 / den);
        const beatsPerMeasure = num;
        for (const n of notes || []) {
          const startBeats = ticksToBeats(n.ticks || 0);
          const durBeats = ticksToBeats(n.durationTicks || 0);
          const m = Math.floor(startBeats / beatsPerMeasure);
          const entry = {
            name: n.name,
            beats: Math.max(durBeats, 0.0001),
            startTicks: n.ticks || 0,
            endTicks: (n.ticks || 0) + (n.durationTicks || 0)
          };
          if (!measures.has(m)) measures.set(m, []);
          measures.get(m).push(entry);
        }
        const maxMeasureIdx = measures.size ? Math.max(...measures.keys()) : 0;
        return { measures, maxMeasureIdx, beatsPerMeasure };
      }, [notes, timeSig, ppq]);

      // Layout constants (kept in sync with draw routine)
      const paddingX = 20;
      const systemTop = 8;
      const systemGap = 28;
      const rowsCount = React.useMemo(() =>
        Math.ceil((measureData.maxMeasureIdx + 1) / measuresPerRow), [measureData, measuresPerRow]);
      const rowHeight = React.useMemo(() => (height - systemTop * 2 - systemGap) / 2, [height, systemTop, systemGap]);
      const systemWidth = React.useMemo(() => width - paddingX * 2, [width, paddingX]);
      const measureWidth = React.useMemo(() => systemWidth / measuresPerRow, [systemWidth, measuresPerRow]);
      const contentHeight = React.useMemo(() =>
        systemTop + rowsCount * (rowHeight + systemGap) - systemGap + 16, [rowsCount, rowHeight, systemGap, systemTop]);

      // Keep rects for each measure (x,y,w,h)
      const rectsRef = React.useRef([]);
      const ticksPerMeasure = React.useMemo(() => {
        const [num, den] = timeSig || [4, 4];
        return (ppq || 480) * num * (4 / den);
      }, [timeSig, ppq]);

      // Draw whole score
      React.useEffect(() => {
        const el = hostRef.current;
        if (!el) return;
        const VF = window.VF;
        if (!VF) return;
        el.innerHTML = '';

        const [num, den] = timeSig || [4, 4];
        if (!el.id) el.id = 'vf_score_' + Math.random().toString(36).slice(2);
        const factory = new VF.Factory({
          renderer: { elementId: el.id, width, height: contentHeight, backend: VF.Renderer.Backends.SVG }
        });
        const score = factory.EasyScore();
        const NOTE_COLOR = '#cbd5e1';

        const beatsPerMeasure = num;
        const toVexKey = (name) => {
          const m = /^([A-Ga-g])([b#]?)(-?\d+)$/.exec(name || 'C4');
          if (!m) return 'c/4';
          const letter = m[1].toLowerCase();
          const acc = m[2] || '';
          const oct = m[3];
          return `${letter}${acc}/${oct}`;
        };

        // Build rects for each measure (for cursor & seeking)
        rectsRef.current = [];
        const totalMeasures = measureData.maxMeasureIdx + 1;
        const rows = rowsCount;


        for (let mIdx = 0; mIdx < totalMeasures; mIdx++) {
          const row = Math.floor(mIdx / measuresPerRow);
          const col = mIdx % measuresPerRow;
          const sys = factory.System({
            x: paddingX + col * measureWidth,
            y: systemTop + row * (rowHeight + systemGap),
            width: measureWidth,
            spaceBetweenStaves: 0
          });
          const entries = measureData.measures.get(mIdx) || [];
          const tickables = [];
          let used = 0;
          let hadNotes = false;
          for (const e of entries) {
            let q = quantizeBeats(e.beats, den);
            let b = beatsOfVex(q.vex, q.dots, den);
            while (used + b > beatsPerMeasure + 1e-6) {
              const next = shortenQuant(q);
              if (!next) { b = 0; break; }
              q = next; b = beatsOfVex(q.vex, q.dots, den);
            }
            if (b > 1e-6) {
              const n = factory.StaveNote({ keys: [toVexKey(e.name || 'C4')], duration: q.vex });
              n.setStyle({ fillStyle: NOTE_COLOR, strokeStyle: NOTE_COLOR });
              const accMatch = /^([A-Ga-g])([b#]?)(-?\d+)$/.exec(e.name || '');
              const accSym = accMatch ? (accMatch[2] || '') : '';
              if (accSym) n.addAccidental(0, new VF.Accidental(accSym));
              if (q.dots) n.addDot(0);

              // push ticks to DOM for cursor tracking
              if (n.setAttribute) {
                n.setAttribute('data-start-ticks', String(e.startTicks || 0));
                n.setAttribute('data-end-ticks', String(e.endTicks || 0));
                n.setAttribute('data-measure', String(mIdx));
                const midi = noteNameToMidi(e.name); if (midi != null) n.setAttribute('data-midi', String(midi));
              }

              tickables.push(n);
              used += b;
              hadNotes = true;
              if (used >= beatsPerMeasure - 1e-6) break;
            }
          }
          const addRestsToFill = (rem) => {
            const order = ['w', 'h', 'q', '8', '16', '32'];
            while (rem > 1e-6) {
              let placed = false;
              for (const s of order) {
                const sb = beatsOfVex(s, 0, den);
                if (sb <= rem + 1e-6) {
                  const r = factory.StaveNote({ keys: ['b/4'], duration: s + 'r' });
                  r.setStyle?.({ fillStyle: NOTE_COLOR, strokeStyle: NOTE_COLOR });
                  tickables.push(r); rem -= sb; placed = true; break;
                }
              }
              if (!placed) break;
            }
          };
          const remaining = beatsPerMeasure - used;
          if (remaining > 1e-6) {
            if (hadNotes) addRestsToFill(remaining);
            else tickables.push(new VF.GhostNote({ duration: 'w' }));
          }
          if (hadNotes) tickables.unshift(new VF.GhostNote({ duration: '16' }));
          const voice = factory.Voice({ time: `${num}/${den}` }); voice.setStrict?.(false);
          if (VF.Voice?.Mode && voice.setMode) voice.setMode(VF.Voice.Mode.SOFT);
          voice.addTickables(tickables);
          const stave = sys.addStave({ voices: [voice] });
          if (mIdx === 0) stave.addClef('treble').addTimeSignature(`${num}/${den}`);

          // record rect
          rectsRef.current[mIdx] = {
            x: paddingX + col * measureWidth,
            y: systemTop + row * (rowHeight + systemGap),
            w: measureWidth,
            h: rowHeight
          };
        }

        factory.draw();

        try {
          const svg = el.querySelector('svg');
          noteElsRef.current = [];
          if (svg) {
            const nodes = svg.querySelectorAll('g.vf-stavenote[data-start-ticks]');
            noteElsRef.current = Array.from(nodes).map(g => ({
              el: g,
              start: +(g.getAttribute('data-start-ticks') || '0'),
              end: +(g.getAttribute('data-end-ticks') || '0'),
              midi: (g.hasAttribute('data-midi') ? +(g.getAttribute('data-midi') || 'NaN') : NaN)
            })).sort((a, b) => a.start - b.start);
          }
        } catch { }


        try {
          const svg = el.querySelector('svg');
          if (svg) {
            const UI = '#cbd5e1';      // your slate-300
            const STAFF = '#94a3b8';   // your slate-400

            const fillSel = [
              'path[fill="black"]',
              'path[fill="#000"]',
              'path[fill="rgb(0, 0, 0)"]',
              'rect[fill="black"]',
              'rect[fill="#000"]',
              'rect[fill="rgb(0, 0, 0)"]'
            ].join(',');
            const strokeSel = [
              'path[stroke="black"]',
              'path[stroke="#000"]',
              'path[stroke="rgb(0, 0, 0)"]',
              'rect[stroke="black"]',
              'rect[stroke="#000"]',
              'rect[stroke="rgb(0, 0, 0)"]'
            ].join(',');

            svg.querySelectorAll(fillSel).forEach(n => n.setAttribute('fill', UI));
            svg.querySelectorAll(strokeSel).forEach(n => n.setAttribute('stroke', UI));

            // Staff lines & barlines a touch dimmer than glyphs:
            svg.querySelectorAll('.vf-stave path, .vf-barline path').forEach(n => n.setAttribute('stroke', STAFF));
          }
        } catch { }


        try {
          const svg = el.querySelector('svg');
          const UI_COLOR = '#cbd5e1';
          if (!svg) return;
          const sets = [
            '.vf-clef *',
            '.vf-clef_treble *',
            'g[class*="clef"] *',
            '.vf-timeSig *',
            '.vf-timesig *',
            '.vf-time-signature *',
            'g[class*="timesig"] *'
          ];
          sets.forEach(sel => {
            svg.querySelectorAll(sel).forEach(n => {
              n.setAttribute?.('fill', UI_COLOR);
              n.setAttribute?.('stroke', UI_COLOR);
            });
          });
          // Optional: brighten staff & barlines via JS too.
          svg.querySelectorAll('.vf-stave path, .vf-barline path').forEach(n => {
            n.setAttribute?.('stroke', '#94a3b8');
          });
        } catch {
          /* no-op */
        }
      }, [measureData, timeSig, width, height, ppq, contentHeight, measureWidth, rowHeight, systemGap, systemTop, measuresPerRow, rowsCount]);

      // Update yellow cursor + autoscroll once per *row* (snap row to top)
      React.useEffect(() => {
        const overlay = overlayRef.current;
        const scroller = scrollRef.current;
        if (!overlay || !scroller || !rectsRef.current.length) return;

        // Where is the cursor inside the current measure?
        const idx = Math.max(0, Math.floor((currentTicks || 0) / (ticksPerMeasure || 1)));
        const frac = ((currentTicks || 0) % (ticksPerMeasure || 1)) / (ticksPerMeasure || 1);
        const rect = rectsRef.current[idx] || rectsRef.current[rectsRef.current.length - 1];
        const x = (rect?.x || 0) + frac * (rect?.w || 0);
        const y = rect?.y || 0;
        const h = rect?.h || 0;
        overlay.style.transform = `translate(${Math.round(x)}px, ${Math.round(y)}px)`;
        overlay.style.height = `${Math.round(h)}px`;

        // Only scroll when the *row* changes (not every measure)
        const rowNow = Math.floor(idx / (measuresPerRow || 1));
        const rowPrev = Math.floor((lastMeasureRef.current >= 0 ? lastMeasureRef.current : 0) / (measuresPerRow || 1));
        if (running && !draggingRef.current && rowNow !== rowPrev) {
          lastMeasureRef.current = idx;
          const firstMeasureOfRow = rowNow * (measuresPerRow || 1);
          const rowRect = rectsRef.current[firstMeasureOfRow];
          const targetTop = Math.max(0, (rowRect?.y || 0) - 8);

          // Prefer native smooth scroll; fallback to RAF if needed
          try {
            scroller.scrollTo({ top: targetTop, behavior: 'smooth' });
          } catch {
            const startTop = scroller.scrollTop;
            const dist = targetTop - startTop;
            const dur = 250;
            const t0 = performance.now();
            const ease = (t) => (t < .5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2);
            let raf;
            const step = () => {
              const p = Math.min(1, (performance.now() - t0) / dur);
              scroller.scrollTop = startTop + dist * ease(p);
              if (p < 1) raf = requestAnimationFrame(step);
            };
            raf = requestAnimationFrame(step);
            return () => cancelAnimationFrame(raf);
          }
        } else {
          lastMeasureRef.current = idx;
        }
      }, [currentTicks, ticksPerMeasure, running, measuresPerRow]);


      React.useEffect(() => {
        const list = noteElsRef.current;
        if (!list || !list.length) return;
        const t = currentTicks || 0;
        const tickWindow = Math.max(1, (ppq || 480) * 0.02);
        // find the current score note (by ticks)
        let found = null;
        for (let i=0;i<list.length;i++){
          const n = list[i];
          if (t >= (n.start - tickWindow) && t <= (n.end + tickWindow)) { found = n; break; }
        }
        // painter
        const paint = (el, fill) => {
          el.querySelectorAll('path, ellipse, circle, rect').forEach(n=>{
            if (n.getAttribute('data-skip-style') === '1') return;
            if (fill) { n.setAttribute('fill', fill); n.setAttribute('stroke', fill); }
          });
          if (fill === '#22c55e') el.classList.add('note-glow'); else el.classList.remove('note-glow');
        };
        // Clear previous highlight if needed
        const clearPrev = () => {
          if (ScoreDisplay.__lastHi) {
            paint(ScoreDisplay.__lastHi, '#cbd5e1');
            ScoreDisplay.__lastHi = null;
          }
        };
        // Only show mic-driven colouring if mic is enabled
        if (!micEnabled || !micNote) { clearPrev(); return; }
        // Reset all when target note changes
        if (ScoreDisplay.__lastHi && ScoreDisplay.__lastHi !== found?.el) {
          paint(ScoreDisplay.__lastHi, '#cbd5e1');
          ScoreDisplay.__lastHi = null;
        }
        if (!found) { clearPrev(); return; }
        // Decide green/red using tolerance (unless expert mode)
        let good = false;
        // expected MIDI from DOM (may be NaN if unavailable)
        const expMidi = Number.isFinite(found.midi) ? found.midi : NaN;
        if (Number.isFinite(expMidi)) {
          if (expertMode) {
            good = (micNote.midi === expMidi);
          } else {
            const targetFreq = midiToFreq(expMidi);
            const diff = centsDiff(micNote.freq, targetFreq);
            good = Math.abs(diff) <= (toleranceCents || 35);
          }
        }
        const color = good ? '#22c55e' : '#ef4444';
        paint(found.el, color);
        ScoreDisplay.__lastHi = found.el;
      }, [currentTicks, ppq, micEnabled, micNote, expertMode, toleranceCents]);


      // Drag to scroll + click to seek
      const onMouseDown = (e) => {
        draggingRef.current = true;
        dragStart.current = { y: e.clientY, top: scrollRef.current?.scrollTop || 0 };
        scrollRef.current?.classList.add('cursor-grabbing');
      };
      const onMouseMove = (e) => {
        if (!draggingRef.current) return;
        const dy = e.clientY - dragStart.current.y;
        const sc = scrollRef.current;
        if (sc) sc.scrollTop = dragStart.current.top - dy;
      };
      const endDrag = () => {
        draggingRef.current = false;
        scrollRef.current?.classList.remove('cursor-grabbing');
      };
      const onClick = (e) => {
        if (Math.abs((scrollRef.current?.scrollTop || 0) - dragStart.current.top) > 2) return;
        const host = hostRef.current;
        if (!host || !rectsRef.current.length) return;
        const bounds = host.getBoundingClientRect();
        const x = e.clientX - bounds.left;
        const y = e.clientY - bounds.top;
        const col = clamp(Math.floor((x - paddingX) / measureWidth), 0, measuresPerRow - 1);
        const row = clamp(Math.floor((y - systemTop) / (rowHeight + systemGap)), 0, rowsCount - 1);
        const idx = clamp(row * measuresPerRow + col, 0, rectsRef.current.length - 1);
        const rect = rectsRef.current[idx];
        if (!rect) return;
        const frac = clamp((x - rect.x) / rect.w, 0, 1);
        const targetTicks = Math.round(idx * ticksPerMeasure + frac * ticksPerMeasure);
        onSeekTicks && onSeekTicks(targetTicks);
      };

      return (
        <div className="w-full h-full relative">
          <div
            ref={scrollRef}
            className="absolute inset-0 overflow-y-auto overflow-x-hidden select-none cursor-grab"
            onMouseDown={onMouseDown}
            onMouseMove={onMouseMove}
            onMouseLeave={endDrag}
            onMouseUp={endDrag}
            onClick={onClick}
          >
            <div style={{ position: 'relative', width: `${width}px`, height: `${contentHeight}px` }}>
              <div ref={hostRef} className="vf-host absolute inset-0" />
              <div
                ref={overlayRef}
                style={{
                  position: 'absolute', left: 0, top: 0, width: '2px',
                  background: '#fde047',
                  boxShadow: '0 0 0 2px rgba(253,224,71,.25), 0 0 12px rgba(253,224,71,.6)',
                  pointerEvents: 'none'
                }}
              />
            </div>
          </div>
        </div>
      );
    }

    /******************************
     * Canvas Note Highway
     ******************************/
    function NoteHighway({
      laneEvents,
      keyStateMask,
      width,
      height,
      lookahead = 3.5, // seconds from top to hit line
      onHitJudgement, // (evt, ok, errorMs)
      running,
      currentTicks,    // live transport ticks (tempo-scaled)
      bpm,
      ppq = 480
    }) {

      const canvasRef = useRef(null);
      const rafRef = useRef(null);
      const tickRef = useRef(0);
      useEffect(() => { tickRef.current = currentTicks || 0; }, [currentTicks]);

      const hitYRatio = 0.88; // the hit line y position (as a proportion of height)
      const vanishYRatio = 0.18;           // where things originate (near top)
      const laneGapAtHit = 28;             // px gap between lanes AT THE HIT LINE
      const totalWidthFrac = 0.8;          // how much of screen width the runway uses at hit line
      const minLaneWidthFar = 0;           // lane width “in the distance”
      const gamma = 1.15;                  // easing for depth → screen mapping

      const [frame, setFrame] = useState(0); // force updates on resize

      // Resize canvas to DPR
      const resizeCanvas = useCallback(() => {
        const c = canvasRef.current;
        if (!c) return;
        const dpr = window.devicePixelRatio || 1;
        c.width = Math.round(width * dpr);
        c.height = Math.round(height * dpr);
        c.style.width = width + 'px';
        c.style.height = height + 'px';
        const ctx = c.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        setFrame(f => f + 1);
      }, [width, height]);

      useEffect(() => {
        resizeCanvas();
        const onResize = () => resizeCanvas();
        window.addEventListener('resize', onResize);
        return () => window.removeEventListener('resize', onResize);
      }, [resizeCanvas]);

      useEffect(() => {
        const c = canvasRef.current;
        if (!c) return;
        const ctx = c.getContext('2d');

        const laneCount = 3;
        const hitY = Math.round(height * hitYRatio);
        const vanishY = Math.round(height * vanishYRatio);
        const centerX = width / 2;
        const usableWidthAtHit = Math.min(width * totalWidthFrac, 560);
        const laneWidthAtHit = (usableWidthAtHit - laneGapAtHit * (laneCount - 1)) / laneCount;
        const startLeftAtHit = centerX - usableWidthAtHit / 2;
        const laneCenterAtHit = (i) => (
          startLeftAtHit + i * (laneWidthAtHit + laneGapAtHit) + laneWidthAtHit / 2
        );
        const laneColors = ['#23f5b0', '#ffd33d', '#8ae1ff']; // per-valve
        const receptorRadius = 11;

        // Project a param u in [0..1] (0=far, 1=at hit line) to y coordinate
        const uToY = (u) => {
          const eased = Math.pow(u, gamma);
          return vanishY + (hitY - vanishY) * eased;
        };
        // For a lane i and progress u, return [cx, w] at that depth
        const laneGeom = (i, u) => {
          const cxHit = laneCenterAtHit(i);
          const cx = centerX + (cxHit - centerX) * u; // converge to center at distance
          const w = minLaneWidthFar + (laneWidthAtHit - minLaneWidthFar) * u;
          return [cx, w];
        };

        function drawTopRoundedTrapezoid(xSL, xSR, yStart, xEL, xER, yEnd /* rTop unused */) {
          ctx.beginPath();
          ctx.moveTo(xSL, yStart);     // top-left
          ctx.lineTo(xSR, yStart);     // top-right (dead flat)
          ctx.lineTo(xER, yEnd);       // down right side
          ctx.lineTo(xEL, yEnd);       // bottom
          ctx.closePath();
        }




        function drawBackground() {
          ctx.clearRect(0, 0, width, height);
          ctx.shadowColor = 'rgba(0,190,255,0.25)';
          ctx.shadowBlur = 8;
          ctx.fillStyle = 'rgba(10,20,38,0.75)';
          ctx.fillRect(0, 0, width, height);
          // Perspective “rails” per lane
          for (let i = 0; i < laneCount; i++) {
            ctx.beginPath();
            // far
            const u0 = 0;
            const y0 = uToY(u0);
            const [cx0, w0] = laneGeom(i, u0);
            // near
            const u1 = 1;
            const y1 = uToY(u1);
            const [cx1, w1] = laneGeom(i, u1);
            ctx.moveTo(cx0 - w0 / 2, y0);
            ctx.lineTo(cx1 - w1 / 2, y1);
            ctx.lineTo(cx1 + w1 / 2, y1);
            ctx.lineTo(cx0 + w0 / 2, y0);
            ctx.closePath();
            ctx.fillStyle = 'rgba(10,20,38,0.88)';
            ctx.fill();
            ctx.lineWidth = 1.25;
            ctx.strokeStyle = 'rgba(40,120,255,0.35)';
            ctx.stroke();
          }

          // Hit line & receptors
          ctx.strokeStyle = 'rgba(150,183,255,0.5)';
          ctx.lineWidth = 2;
          ctx.setLineDash([6, 6]);
          ctx.beginPath(); ctx.moveTo(0, hitY); ctx.lineTo(width, hitY); ctx.stroke();
          ctx.setLineDash([]);

          for (let i = 0; i < laneCount; i++) {
            const [cx, w] = laneGeom(i, 1);
            const bit = (i === 0 ? VALVE1 : (i === 1 ? VALVE2 : VALVE3));
            const pressed = !!(keyStateMask & bit);
            const halo = pressed ? 10 : 6;
            ctx.beginPath();
            ctx.arc(cx, hitY, receptorRadius + (pressed ? 2 : 0), 0, Math.PI * 2);
            ctx.fillStyle = pressed ? laneColors[i] : 'rgba(16,28,50,0.92)';
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = pressed ? 'rgba(255,255,255,0.95)' : 'rgba(148,163,184,0.28)';
            ctx.stroke();
            if (pressed) {
              ctx.shadowColor = laneColors[i];
              ctx.shadowBlur = halo * 0.7;
              ctx.beginPath();
              ctx.arc(cx, hitY, receptorRadius + 10, 0, Math.PI * 2);
              ctx.strokeStyle = laneColors[i];
              ctx.stroke();
              ctx.shadowBlur = 0;
              const t = performance.now() / 600;
              ctx.setLineDash([4, 6]);
              ctx.beginPath();
              ctx.arc(cx, hitY, receptorRadius + 14, t, t + Math.PI * 1.2);
              ctx.strokeStyle = 'rgba(255,255,255,0.55)'; ctx.lineWidth = 1;
              ctx.stroke(); ctx.setLineDash([]);

            }
          }
        }


        // Pre-calc to speed drawing
        const secToTicks = (sec) => (ppq * (bpm / 60)) * sec;
        let lookaheadTicks = secToTicks(lookahead);

        function drawNotes() {
          const nowT = tickRef.current;
          // recompute in case BPM changed since effect mount
          lookaheadTicks = secToTicks(lookahead);
          const startWindow = nowT;
          const endWindow = nowT + lookaheadTicks;

          ctx.shadowBlur = 0;

          for (const ev of laneEvents) {
            // Skip those far away (before or after)
            if ((ev.endTicks || 0) < startWindow - ppq * 0.05) continue; // long gone
            if ((ev.startTicks || 0) > endWindow + ppq * 0.05) break;    // not yet
            // Perspective mapping for start/end
            const startDT = (ev.startTicks || 0) - nowT; // ticks until hit
            const endDT = (ev.endTicks || 0) - nowT;
            const uStart = clamp(1 - (startDT / lookaheadTicks), 0, 1);
            const uEnd = clamp(1 - (endDT / lookaheadTicks), 0, 1);
            const yStart = uToY(uStart);
            const yEnd = uToY(uEnd);
            const minH = 6;

            const topIsEnd = yEnd < yStart;
            const yTop = topIsEnd ? yEnd : yStart;
            const yBot = topIsEnd ? yStart : yEnd;

            const heightNow = Math.max(yBot - yTop, minH);

            // OPEN note? Draw a full-width translucent white band (no perspective).
            if (ev.open) {
              // trailing glow (use the note color)
              ctx.save();
              ctx.globalCompositeOperation = 'lighter';
              ctx.globalAlpha = 0.10;
              ctx.fillStyle = ev.color;
              ctx.fillRect(0, yTop - 4, width, heightNow + 8);
              ctx.restore();

              // main band in the note color
              ctx.save();
              ctx.globalAlpha = 0.28;
              ctx.fillStyle = ev.color;
              ctx.fillRect(0, yTop, width, heightNow);
              ctx.restore();

              // subtle edges
              ctx.strokeStyle = 'rgba(255,255,255,0.28)';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(0, yTop); ctx.lineTo(width, yTop);
              ctx.moveTo(0, yTop + heightNow); ctx.lineTo(width, yTop + heightNow);
              ctx.stroke();

              // Judgement for open notes: hit if *no keys* are pressed at the start edge
              if (!ev.judged) {
                const msPerTick = 60000 / (ppq * bpm);
                const errorMs = ((ev.startTicks || 0) - nowT) * msPerTick;
                if (Math.abs(errorMs) <= 80) {
                  const ok = (keyStateMask === 0);
                  ev.hit = ok || ev.hit;
                  ev.judged = true;
                  onHitJudgement && onHitJudgement(ev, ok, errorMs);
                } else if (errorMs < -150) {
                  ev.judged = true;
                  onHitJudgement && onHitJudgement(ev, false, errorMs);
                }
              }
              continue; // skip the lane-based drawing
            }

            const [cxTop, wTop] = laneGeom(
              ev.lane,
              topIsEnd ? Math.max(uEnd, 0.001) : uStart
            );
            const [cxBot, wBot] = laneGeom(
              ev.lane,
              topIsEnd ? uStart : Math.max(uEnd, 0.001)
            );
            const xSL = cxTop - wTop * 0.5;
            const xSR = cxTop + wTop * 0.5;
            const xEL = cxBot - wBot * 0.5;
            const xER = cxBot + wBot * 0.5;


            // 1) Tight, centered trail
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const trailSteps = 2;
            for (let t = trailSteps; t >= 1; t--) {
              const alpha = 0.05 * t;           // lower intensity
              const yShift = -t * 3;            // shorter smear
              ctx.save();
              ctx.translate(0, yShift);
              drawTopRoundedTrapezoid(
                xSL, xSR, yTop,
                xEL, xER, yTop + heightNow,
                8                                  // small top radius
              );
              ctx.fillStyle = ev.color;
              ctx.globalAlpha = alpha;
              ctx.fill();
              ctx.restore();
            }
            ctx.restore();

            const prevJoin = ctx.lineJoin, prevMiter = ctx.miterLimit;
            ctx.lineJoin = 'bevel';
            ctx.miterLimit = 2;

            drawTopRoundedTrapezoid(
              xSL, xSR, yTop,
              xEL, xER, yTop + heightNow,
              0                                  // top radius only
            );
            ctx.fillStyle = ev.hit ? 'rgba(68,224,166,1)' : ev.color;
            ctx.globalAlpha = 0.98;
            ctx.fill();

            // 3) Subtle edge & inner lift 
            ctx.lineWidth = 1.1;
            ctx.strokeStyle = 'rgba(2,6,23,0.55)';
            ctx.stroke();
            ctx.lineJoin = prevJoin; ctx.miterLimit = prevMiter;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 0.08;
            // inset a hair for a soft spec highlight
            drawTopRoundedTrapezoid(
              xSL + 1, xSR - 1, yTop + 0.5,
              xEL + 1, xER - 1, yTop + heightNow - 0.5,
              0
            );
            ctx.fillStyle = ev.color;
            ctx.fill();
            ctx.restore();


            // Judge near hit line only once
            if (!ev.judged) {
              // If start passes within +-80ms (convert ticks->ms at current BPM)
              const msPerTick = 60000 / (ppq * bpm);
              const errorMs = ((ev.startTicks || 0) - nowT) * msPerTick;

              if (Math.abs(errorMs) <= 80) {
                const laneBit = (ev.lane === 0 ? VALVE1 : (ev.lane === 1 ? VALVE2 : VALVE3));
                const ok = !!(keyStateMask & laneBit);
                ev.hit = ok || ev.hit; // keep any hit true
                ev.judged = true;
                onHitJudgement && onHitJudgement(ev, ok, errorMs);
              } else if (errorMs < -150) {
                // Missed decisively
                ev.judged = true;
                onHitJudgement && onHitJudgement(ev, false, errorMs);
              }
            }
          }
          ctx.shadowBlur = 0;
        }

        let view = { running: true };
        function loop() {
          if (!view.running) return;
          drawBackground();
          drawNotes();
          rafRef.current = requestAnimationFrame(loop);
        }
        view.running = true;
        loop();

        return () => {
          view.running = false;
          if (rafRef.current) cancelAnimationFrame(rafRef.current);
        };
      }, [laneEvents, keyStateMask, width, height, lookahead, running, frame, hitYRatio, vanishYRatio, bpm, ppq]);

      return <canvas ref={canvasRef} className="w-full h-full rounded-md bg-transparent" />;
    }

    /******************************
     * Microphone Pitch (simple autocorrelation)
     ******************************/
    function useMicPitch(enabled) {
      const [note, setNote] = useState(null); // { midi, freq, cents }
      const analyserRef = useRef(null);
      const sourceRef = useRef(null);
      const rafRef = useRef(null);
      const audioCtxRef = useRef(null);
      const bufRef = useRef(null);

      useEffect(() => {
        async function start() {
          if (!enabled) return;
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          audioCtxRef.current = audioCtx;
          const analyser = audioCtx.createAnalyser();
          analyser.fftSize = 2048;
          analyserRef.current = analyser;
          const source = audioCtx.createMediaStreamSource(stream);
          source.connect(analyser);
          sourceRef.current = source;

          bufRef.current = new Float32Array(analyser.fftSize);

          const ac = () => {
            if (!analyserRef.current) return;
            const buf = bufRef.current;
            analyser.getFloatTimeDomainData(buf);
            const f = autoCorrelate(buf, audioCtx.sampleRate);
            if (f > 40 && f < 2000) {
              const midi = freqToMidi(f);
              const ref = 440 * Math.pow(2, (midi - 69) / 12);
              const cents = Math.floor(1200 * Math.log2(f / ref));
              setNote({ midi, freq: f, cents });
            } else {
              setNote(null);
            }
            rafRef.current = requestAnimationFrame(ac);
          };
          ac();
        }
        start().catch(() => { });
        return () => {
          if (rafRef.current) cancelAnimationFrame(rafRef.current);
          try {
            analyserRef.current?.disconnect();
            sourceRef.current?.disconnect();
            audioCtxRef.current?.close();
          } catch { }
          analyserRef.current = null;
          sourceRef.current = null;
          audioCtxRef.current = null;
          setNote(null);
        };
      }, [enabled]);

      return note;
    }

    function autoCorrelate(buf, sampleRate) {
      // A basic autocorrelation pitch estimator
      const SIZE = buf.length;
      let rms = 0;
      for (let i = 0; i < SIZE; i++) { const val = buf[i]; rms += val * val; }
      rms = Math.sqrt(rms / SIZE);
      if (rms < 0.01) return -1;

      let r1 = 0, r2 = SIZE - 1, thres = 0.2;
      for (let i = 0; i < SIZE / 2; i++) if (Math.abs(buf[i]) < thres) { r1 = i; break; }
      for (let i = 1; i < SIZE / 2; i++) if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }

      const buf2 = buf.slice(r1, r2);
      const newSize = buf2.length;
      const c = new Array(newSize).fill(0);
      for (let i = 0; i < newSize; i++) {
        for (let j = 0; j < newSize - i; j++) c[i] += buf2[j] * buf2[j + i];
      }
      let d = 0; while (c[d] > c[d + 1]) d++;
      let maxval = -1, maxpos = -1;
      for (let i = d; i < newSize; i++) {
        if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
      }
      if (maxpos <= 0) return -1;
      // Interpolate
      const T0 = maxpos;
      const x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1] || x2;
      const a = (x1 + x3 - 2 * x2) / 2;
      const b = (x3 - x1) / 2;
      const shift = a ? -b / (2 * a) : 0;
      const period = T0 + shift;
      const freq = sampleRate / period;
      return freq;
    }

    /******************************
     * Controls
     ******************************/
    function Controls({
      isLoaded, running, onPlayPause, bpm, onBpm, onFile, trackNames, trackIndex, onTrackIndex,
      stats, micNote
    }) {
      return (
        <div className="hud w-full">
          <button
            className="pill hover:brightness-110 disabled:opacity-40"
            onClick={onPlayPause}
            disabled={!isLoaded}
            title={running ? "Pause (Space)" : "Play (Space)"}
          >
            {running ? 'Pause' : 'Play'}
          </button>

          <label className="pill flex items-center gap-2 text-sm">
            <span className="text-slate-300">Tempo</span>
            <input
              className="w-40"
              type="range" min="40" max="200" step="1"
              value={bpm}
              onChange={(e) => onBpm(+e.target.value)}
            />
            <span className="w-10 text-right">{bpm}</span>
            <span className="text-slate-400 text-xs ml-1">BPM</span>
          </label>

          <label className="pill flex items-center gap-2 text-sm">
            <span className="text-slate-300">Track</span>
            <select
              className="bg-slate-900/70 border border-slate-700/60 rounded px-2 py-1"
              value={trackIndex ?? 0}
              onChange={(e) => onTrackIndex(+e.target.value)}
              disabled={!isLoaded}
            >
              {(trackNames || []).map((t, i) => <option key={i} value={i}>{t || `Track ${i + 1}`}</option>)}
            </select>
          </label>

          <label className="ml-auto text-sm flex items-center gap-2">
            <input
              className="hidden"
              id="midiFile"
              type="file"
              accept=".mid,.midi,audio/midi"
              onChange={(e) => onFile(e.target.files?.[0] || null)}
            />
            <span className="pill cursor-pointer hover:brightness-110">
              <label htmlFor="midiFile" className="cursor-pointer">Upload MIDI</label>
            </span>
          </label>

          {/* Stats (time-based) */}
          <div className="text-xs text-slate-300">
            <span className="mr-3">
              Hit:{" "}
              <span className="font-semibold" style={{ color: 'var(--laneA)' }}>
                <span className="inline-block w-[6ch] text-right tabular-nums font-mono">
                  {stats.hitTime.toFixed(2)}
                </span>
                s
              </span>
            </span>
            <span className="mr-3">
              Miss:{" "}
              <span className="font-semibold text-rose-400">
                <span className="inline-block w-[6ch] text-right tabular-nums font-mono">
                  {stats.missTime.toFixed(2)}
                </span>
                s
              </span>
            </span>
            <span>
              Acc:{" "}
              <span className="font-semibold">
                <span className="inline-block w-[4ch] text-right tabular-nums font-mono">
                  {(stats.hitTime + stats.missTime) > 0
                    ? Math.round(100 * stats.hitTime / (stats.hitTime + stats.missTime))
                    : 0}
                </span>
                %
              </span>
            </span>
          </div>


          {/* Mic readout */}
          <div className="text-xs text-slate-400 ml-3">
            Mic: {micNote ? `MIDI ${micNote.midi} (${micNote.cents > 0 ? '+' : ''}${micNote.cents}¢)` : '—'}
          </div>
        </div>
      );
    }

    /******************************
     * Menu / Settings
     ******************************/
    function MenuPane({
      open, onClose,
      keyMap, setKeyMap,
      lookahead, setLookahead,
      micEnabled, setMicEnabled,
      expertMode, setExpertMode
    }) {
      const [capturing, setCapturing] = useState(null); // 'valve1' | ...

      useEffect(() => {
        function onKey(e) {
          if (!capturing) return;
          e.preventDefault();
          const k = e.key.toLowerCase();
          const updated = { ...keyMap };
          const v = capturing === 'valve1' ? VALVE1 : capturing === 'valve2' ? VALVE2 : VALVE3;
          // Remove previous mapping of this valve
          for (const kk of Object.keys(updated)) {
            if (updated[kk] === v) delete updated[kk];
          }
          updated[k] = v;
          setKeyMap(updated);
          setCapturing(null);
        }
        if (capturing) window.addEventListener('keydown', onKey, { once: true });
        return () => window.removeEventListener('keydown', onKey);
      }, [capturing, keyMap, setKeyMap]);

      if (!open) return null;
      return (
        <div className="fixed inset-0 z-50">
          <div className="absolute inset-0 bg-black/60" onClick={onClose}></div>
          <div className="absolute left-0 top-0 h-full w-[320px] bg-slate-800 shadow-xl p-4 overflow-y-auto">
            <div className="flex items-center justify-between pb-2 mb-2 border-b border-slate-700">
              <h2 className="text-lg font-semibold">Settings</h2>
              <button onClick={onClose} className="text-slate-300 hover:text-white">✕</button>
            </div>

            <section className="mb-6">
              <h3 className="font-semibold mb-2">Input mapping</h3>
              <p className="text-xs text-slate-400 mb-2">Press a button to re-map; currently:</p>
              <KeyMapRow
                label="Valve 1"
                capture={() => setCapturing('valve1')}
                active={capturing === 'valve1'}
                currentKey={displayKeyForValve(keyMap, VALVE1)}
              />
              <KeyMapRow
                label="Valve 2"
                capture={() => setCapturing('valve2')}
                active={capturing === 'valve2'}
                currentKey={displayKeyForValve(keyMap, VALVE2)}
              />
              <KeyMapRow
                label="Valve 3"
                capture={() => setCapturing('valve3')}
                active={capturing === 'valve3'}
                currentKey={displayKeyForValve(keyMap, VALVE3)}
              />
              <div className="mt-3">
                <button className="text-xs underline text-slate-300" onClick={() => setKeyMap({ ...defaultKeyMap })}>Reset to A/S/D</button>
              </div>
            </section>

            <section className="mb-6">
              <h3 className="font-semibold mb-2">Visual difficulty</h3>
              <label className="text-sm text-slate-300">Note speed (seconds top → hit)</label>
              <input
                className="w-full mt-2"
                type="range" min="2" max="6" step="0.1"
                value={lookahead}
                onChange={(e) => setLookahead(+e.target.value)}
              />
              <div className="text-xs text-slate-400 mt-1">{lookahead.toFixed(1)} s</div>
            </section>

            <section className="mb-6">
              <h3 className="font-semibold mb-2">Microphone</h3>
              <label className="flex items-center gap-2 text-sm">
                <input type="checkbox" checked={micEnabled} onChange={(e) => setMicEnabled(e.target.checked)} />
                <span>Enable microphone pitch feedback</span>
              </label>
              <label className="flex items-center gap-2 text-sm mt-2">
                <input
                  type="checkbox"
                  checked={expertMode}
                  onChange={(e) => setExpertMode(e.target.checked)}
                />
                <span>Expert mode (no tolerance)</span>
              </label>
              <p className="text-xs text-slate-400 mt-2">Simple autocorrelation detector; use a quiet room for best results.</p>
            </section>

            <footer className="text-xs text-slate-400">
              <p>Tip: Press Space to Play/Pause.</p>
            </footer>
          </div>
        </div>
      );
    }

    function KeyMapRow({ label, capture, active, currentKey }) {
      return (
        <div className="flex items-center justify-between gap-2 py-1">
          <div>{label}</div>
          <button
            onClick={capture}
            className={'px-3 py-1 rounded border ' + (active ? 'border-emerald-400 text-emerald-300' : 'border-slate-600 text-slate-200')}
            title="Click then press a key"
          >
            {active ? 'Press a key…' : (currentKey || '—')}
          </button>
        </div>
      );
    }

    function displayKeyForValve(keyMap, valveBit) {
      for (const [k, v] of Object.entries(keyMap)) if (v === valveBit) return k.toUpperCase();
      return '';
    }

    /******************************
     * App
     ******************************/
    function App() {
      const [menuOpen, setMenuOpen] = useState(false);
      const [keyMap, setKeyMap] = useState({ ...defaultKeyMap });
      const [pressedMask, setPressedMask] = useState(0);
      const [lookahead, setLookahead] = useState(3.5);
      const [micEnabled, setMicEnabled] = useState(false);
      const [expertMode, setExpertMode] = useState(false);

      const [midiMeta, setMidiMeta] = useState({ title: 'No song loaded', tracks: [] });
      const [trackIndex, setTrackIndex] = useState(0);
      const [notes, setNotes] = useState([]); // selected track notes
      const [laneEvents, setLaneEvents] = useState([]);

      const [bpm, setBpm] = useState(120);
      const [timeSig, setTimeSig] = useState([4, 4]);

      const [running, setRunning] = useState(false);
      const [canvasSize, setCanvasSize] = useState({ w: 800, h: 360 });
      const highwayBoxRef = useRef(null);

      const [stats, setStats] = useState({ hitTime: 0, missTime: 0 });
      const statsRef = useRef({ hitTime: 0, missTime: 0 });
      const pressedMaskRef = useRef(0);
      useEffect(() => { pressedMaskRef.current = pressedMask; }, [pressedMask]);
      const micNote = useMicPitch(micEnabled);

      const { schedulePart, initAudio, readyRef } = useToneSetup();

      // Stable sizing via ResizeObserver (prevents layout creep)
      useEffect(() => {
        const el = highwayBoxRef.current;
        if (!el) return;
        const ro = new ResizeObserver(entries => {
          const r = entries[0].contentRect;
          setCanvasSize({ w: Math.round(r.width), h: Math.round(r.height) });
        });
        // Seed initial size
        const r0 = el.getBoundingClientRect();
        setCanvasSize({ w: Math.round(r0.width), h: Math.round(r0.height) });
        ro.observe(el);
        return () => ro.disconnect();
      }, []);


      // Load MIDI from File
      const onFile = async (file) => {
        if (!file) return;
        const arr = await file.arrayBuffer();
        const MidiClass = window.Midi || (window['tonejsMidi'] && window['tonejsMidi'].Midi) || window['TonejsMidi']?.Midi;
        if (!MidiClass) {
          alert('Failed to load @tonejs/midi. Please check your connection.');
          return;
        }
        const midi = new MidiClass(arr);

        // Header data
        const title = midi.header.name || file.name || 'Untitled';
        const tempos = midi.header.tempos?.length ? midi.header.tempos : [{ bpm: 120, ticks: 0 }];
        const bpm0 = tempos[0].bpm || 120;
        const ts = midi.header.timeSignatures?.length ? midi.header.timeSignatures[0] : { timeSignature: [4, 4] };
        const tsArr = ts.timeSignature || [4, 4];

        setMidiMeta({
          title,
          ppq: midi.header.ppq || 480,
          tracks: midi.tracks.map((t, i) => ({
            name: t.name || `Track ${i + 1}`,
            notes: t.notes?.map(n => ({
              name: n.name,
              midi: n.midi,
              time: n.time,               // seconds (Tone clock)
              duration: n.duration,       // seconds
              ticks: n.ticks,             // absolute ticks from MIDI
              durationTicks: n.durationTicks, // duration in ticks
              velocity: n.velocity
            })) || []
          }))
        });
        setTrackIndex(0);
        setBpm(Math.round(bpm0));
        setTimeSig([tsArr[0] || 4, tsArr[1] || 4]);

        // Select first non-empty track
        const idx = (midi.tracks.findIndex(t => (t.notes?.length || 0) > 0) + midi.tracks.length) % midi.tracks.length;
        setTrackIndex(idx);
        const selectedNotes = midi.tracks[idx].notes?.map(n => ({
          name: n.name,
          midi: n.midi,
          time: n.time,
          duration: n.duration,
          ticks: n.ticks,
          durationTicks: n.durationTicks,
          velocity: n.velocity
        })) || [];
        // normalise starts at 0 for BOTH seconds and ticks
        const t0 = selectedNotes.length ? selectedNotes[0].time : 0;
        const t0Ticks = selectedNotes.length ? selectedNotes[0].ticks : 0;
        selectedNotes.forEach(n => { n.time -= t0; n.ticks -= t0Ticks; });
        setNotes(selectedNotes);

        Tone.Transport.cancel();
        Tone.Transport.bpm.value = bpm0;
        Tone.Transport.position = 0;

        // Schedule audio in Transport ticks (scale MIDI PPQ -> Transport PPQ)
        const transportPPQ = Tone.Transport.PPQ || 192;
        const midiPPQ = midi.header.ppq || 480;
        const scaleToTransport = transportPPQ / midiPPQ;
        schedulePart(selectedNotes, scaleToTransport);

        // Prepare lane events (kept in MIDI ticks space for visuals)
        const events = buildLaneEvents(selectedNotes, bpm0, noteNameToMask, lookahead);
        setLaneEvents(events);

        setRunning(false);
        setStats({ hitTime: 0, missTime: 0 });
        statsRef.current = { hitTime: 0, missTime: 0 };
      };

      // When trackIndex changes
      useEffect(() => {
        if (!midiMeta.tracks.length) return;
        const t = midiMeta.tracks[trackIndex] || midiMeta.tracks[0];
        const n = (t.notes || []).map(x => ({ ...x }));
        if (n.length) {
          const t0 = n[0].time;
          const t0Ticks = n[0].ticks || 0;
          n.forEach(m => { m.time -= t0; m.ticks = (m.ticks || 0) - t0Ticks; });
        }
        setNotes(n);
        Tone.Transport.cancel();
        Tone.Transport.position = 0;
        const transportPPQ = Tone.Transport.PPQ || 192;
        const midiPPQ = midiMeta.ppq || 480;
        const scaleToTransport = transportPPQ / midiPPQ;
        schedulePart(n, scaleToTransport);
        const events = buildLaneEvents(n, bpm, noteNameToMask, lookahead);
        setLaneEvents(events);
        setStats({ hitTime: 0, missTime: 0 });
        statsRef.current = { hitTime: 0, missTime: 0 };
        setRunning(false);
      }, [trackIndex]);

      // Update BPM
      useEffect(() => {
        Tone.Transport.bpm.value = bpm;
      }, [bpm]);

      // Visual-only judgement (keeps lane glow etc.);
      const onHitJudgement = useCallback(() => { pulseAmpRef.current = Math.min(1, pulseAmpRef.current + 0.6); }, []);

      // Play / Pause
      const togglePlay = async () => {
        await initAudio();
        if (!notes.length) return;
        if (Tone.Transport.state !== 'started') {
          Tone.Transport.start('+0.05'); // tiny offset to avoid first-frame stutter
          setRunning(true);
        } else {
          Tone.Transport.pause();
          setRunning(false);
        }
      };

      // End-of-track detection (tick-based, tempo-invariant)
      useEffect(() => {
        if (!notes.length) return;
        let raf = null;
        // compute last MIDI tick in the current notes array
        const lastMidiTick =
          Math.max(0, ...notes.map(n => (n.ticks || 0) + (n.durationTicks || 0)));
        const check = () => {
          // convert Transport ticks -> MIDI ticks for comparison
          const midiPPQ = midiMeta.ppq || 480;
          const transportPPQ = Tone.Transport.PPQ || 192;
          const toMidi = midiPPQ / transportPPQ;
          const nowMidi = (Tone.Transport.ticks || 0) * toMidi;
          // small guard: allow a couple of ticks of slack
          if (nowMidi >= lastMidiTick - 1) {
            setRunning(false);
            Tone.Transport.stop();
            const totalT = stats.hitTime + stats.missTime;
            const acc = totalT ? Math.round(100 * stats.hitTime / totalT) : 0;
            console.log(`Session complete. Accuracy: ${acc}%`);
          } else {
            raf = requestAnimationFrame(check);
          }
        };
        if (running) raf = requestAnimationFrame(check);
        return () => { if (raf) cancelAnimationFrame(raf); };
      }, [running, notes, midiMeta.ppq, stats]);


      // Current Transport seconds -> pass to score / highway AND do time-based scoring
      const [transportTicks, setTransportTicks] = useState(0); // stored as MIDI ticks for UI
      const handleSeekTicks = useCallback((midiTicks) => {
        const midiPPQ = midiMeta.ppq || 480;
        const transportPPQ = Tone.Transport.PPQ || 192;
        const toTransport = transportPPQ / midiPPQ;
        const safeMidi = Math.max(0, Math.round(midiTicks || 0));
        Tone.Transport.ticks = Math.round(safeMidi * toTransport);
        setTransportTicks(safeMidi); // UI stays in MIDI ticks space
      }, [midiMeta.ppq]);


      // helper: find required mask at time t (monophonic expectation)
      const noteCursorRef = useRef(0);
      const getRequiredMaskAtTicks = useCallback((ticksNow) => {
        const arr = notes;
        if (!arr || !arr.length) return null;
        let i = noteCursorRef.current;
        // advance cursor if we've passed the current note (in ticks)
        while (i < arr.length && ((arr[i].ticks || 0) + (arr[i].durationTicks || 0)) <= ticksNow) i++;
        // rewind a little if user scrubbed back / restarted
        while (i > 0 && (arr[i].ticks || 0) > ticksNow) i--;
        noteCursorRef.current = i;
        const n = arr[i];
        if (!n) return null;
        const startT = (n.ticks || 0);
        const endT = startT + (n.durationTicks || 0);
        if (startT <= ticksNow && ticksNow < endT) {
          const m = noteNameToMask(n.name);
          if (m === null) return null;            // out-of-range -> ignore for scoring
          return {
            mask: m,
            startTicks: startT,
            endTicks: endT
          };
        }
        return null; // rest area
      }, [notes]);

      // Track last time the key mask changed (for transition grace)
      const lastKeyChangeSecRef = useRef(0);

      useEffect(() => {
        const markChange = () => { lastKeyChangeSecRef.current = performance.now() / 1000; };
        const handleDown = (e) => {
          const k = e.key.toLowerCase();
          if (k === ' ') { e.preventDefault(); togglePlay(); return; }
          if (keyMap[k]) {
            e.preventDefault();
            setPressedMask((m) => {
              const next = (m | keyMap[k]);
              if (next !== m) markChange();
              return next;
            });
          }
        };
        const handleUp = (e) => {
          const k = e.key.toLowerCase();
          if (keyMap[k]) {
            e.preventDefault();
            setPressedMask((m) => {
              const next = (m & ~keyMap[k]);
              if (next !== m) markChange();
              return next;
            });
          }
        };
        window.addEventListener('keydown', handleDown);
        window.addEventListener('keyup', handleUp);
        return () => {
          window.removeEventListener('keydown', handleDown);
          window.removeEventListener('keyup', handleUp);
        };
      }, [keyMap]); // (replaces the previous key handlers)

      useEffect(() => {
        let raf = null;
        let lastMidiTicks = 0; // we keep all UI/scoring in MIDI ticks
        const tick = () => {
          const midiPPQ = midiMeta.ppq || 480;
          const transportPPQ = Tone.Transport.PPQ || 192;
          const toMidi = midiPPQ / transportPPQ;
          const nowMidi = readyRef.current ? Tone.Transport.ticks * toMidi : 0;
          setTransportTicks(nowMidi);

          const dtTicks = Math.max(0, nowMidi - lastMidiTicks);
          lastMidiTicks = nowMidi;
          if (running && dtTicks > 0.1) { // tiny guard
            const ppq = midiMeta.ppq || 480;               // MIDI PPQ
            const secPerTick = 60 / (ppq * bpm);           // convert MIDI ticks → seconds at current BPM
            const dtSec = dtTicks * secPerTick;

            const reqInfo = getRequiredMaskAtTicks(nowMidi);
            if (reqInfo) {
              const { mask: reqMask, startTicks } = reqInfo;
              const held = pressedMaskRef.current;
              const ok = (held === reqMask);

              // Grace windows
              const changeGraceSec = 0.060;
              const startGraceSec = 0.080;
              const wallNowSec = performance.now() / 1000;
              const withinChangeGrace = (wallNowSec - lastKeyChangeSecRef.current) < changeGraceSec;
              const withinStartGrace = ((nowMidi - startTicks) * secPerTick) < startGraceSec;

              const next = { ...statsRef.current };
              if (ok) {
                next.hitTime += dtSec;
              } else if (withinChangeGrace || withinStartGrace) {
                // don't penalize transition/onset
              } else {
                next.missTime += dtSec;
              }
              statsRef.current = next;
              setStats(next);
            }
          }
          raf = requestAnimationFrame(tick);
        };
        // seed last as MIDI ticks
        if (readyRef.current) {
          const midiPPQ = midiMeta.ppq || 480;
          const transportPPQ = Tone.Transport.PPQ || 192;
          lastMidiTicks = Tone.Transport.ticks * (midiPPQ / transportPPQ);
        } else {
          lastMidiTicks = 0;
        }
        raf = requestAnimationFrame(tick);
        return () => { if (raf) cancelAnimationFrame(raf); };
      }, [running, readyRef, getRequiredMaskAtTicks, bpm, midiMeta.ppq]);

      // Song title
      const songTitle = midiMeta.title || 'Trumpet Trainer';

      // Track names
      const trackNames = (midiMeta.tracks || []).map(t => t.name);

      // Current container sizes
      const scoreHeight = 220; // top-third-ish, responsive
      const highwayHeight = 320;

      const pulseAmpRef = useRef(0);
      useEffect(() => {
        let raf;
        const drive = () => {
          // decay spikes
          pulseAmpRef.current *= 0.92;
          // quarter-note phase (ppq-based so tempo changes are fine)
          const ppq = midiMeta.ppq || 480;
          const ticks = readyRef.current ? Tone.Transport.ticks : 0;
          const p = (ticks % ppq) / ppq;                 // 0..1
          const tri = 1 - Math.abs(2 * p - 1);             // triangle
          const pulse = Math.pow(tri, 2);                // eased
          if (highwayBoxRef.current) {
            highwayBoxRef.current.style.setProperty('--pulse', String(pulse));
            highwayBoxRef.current.style.setProperty('--pulseAmp', String(0.45 + pulseAmpRef.current));
          }
          raf = requestAnimationFrame(drive);
        };
        raf = requestAnimationFrame(drive);
        return () => cancelAnimationFrame(raf);
      }, [midiMeta.ppq, readyRef]);


      return (
        <div className="h-full w-full flex flex-col">
          {/* Top bar */}
          <header className="w-full flex items-center gap-3 px-3 py-2"
            style={{
              background: 'linear-gradient(180deg, rgba(9,14,28,.70), rgba(9,14,28,.25))',
              borderBottom: '1px solid rgba(255,255,255,.06)', backdropFilter: 'blur(6px)'
            }}>
            <button className="p-2 rounded hover:bg-slate-700" onClick={() => setMenuOpen(true)} title="Settings">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-slate-100" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M4 6h16M4 12h16M4 18h16" />
              </svg>
            </button>
            <div className="text-sm text-slate-300">Trumpet Trainer</div>
            <div className="mx-2 w-px h-6 bg-slate-700/80" />
            <div className="font-semibold truncate">{songTitle}</div>
            <div className="ml-auto text-xs opacity-90 flex items-center gap-2">
              <span className="text-slate-300">Valves:</span>
              <span className="kbd" style={{ borderColor: 'rgba(255,255,255,.25)' }}>{displayKeyForValve(keyMap, VALVE1) || 'A'}</span>
              <span className="kbd" style={{ borderColor: 'rgba(255,255,255,.25)' }}>{displayKeyForValve(keyMap, VALVE2) || 'S'}</span>
              <span className="kbd" style={{ borderColor: 'rgba(255,255,255,.25)' }}>{displayKeyForValve(keyMap, VALVE3) || 'D'}</span>
            </div>
          </header>

          {/* Score area */}
          <section className="px-3 pt-3">
            <div className="w-full" style={{ height: scoreHeight + 'px' }}>
              <ScoreDisplay
                notes={notes}
                bpm={bpm}
                timeSig={timeSig}
                ppq={midiMeta.ppq || 480}
                currentTicks={transportTicks}
                running={running}
                width={document.body.clientWidth - 24}
                height={scoreHeight}
                measuresPerRow={2}
                onSeekTicks={handleSeekTicks}
                micEnabled={micEnabled}
                micNote={micNote}
                expertMode={expertMode}
                toleranceCents={35}
              />
            </div>
          </section>

          {/* Highway */}
          <section id="highway" className="flex-1 px-3 py-3">
            <div
              ref={highwayBoxRef}
              className="grid-drift relative w-full h-full min-h-[260px] overflow-hidden"
              style={{
                '--beat': (60 / (bpm || 120)) + 's',
                '--cell': Math.round(
                  Math.max(28, Math.min(64, 52 - (bpm - 120) * 0.10))
                ) + 'px'
              }}
            >
              <NoteHighway
                laneEvents={laneEvents}
                keyStateMask={pressedMask}
                width={canvasSize.w || 800}
                height={canvasSize.h || highwayHeight}
                lookahead={lookahead}
                onHitJudgement={onHitJudgement}
                running={running}
                currentTicks={transportTicks}
                bpm={bpm}
                ppq={midiMeta.ppq || 480}
              />
              {/* Hit line overlay (for visual crispness) */}
              <div className="hitline" style={{ top: ((canvasSize.h || highwayHeight) * 0.88) + 'px' }}></div>
              {/* Lane labels */}
              <div className="absolute left-0 right-0 bottom-1 flex justify-center gap-12 text-xs text-slate-300">
                <div style={{ color: 'var(--laneA)' }}>Valve 1</div>
                <div style={{ color: 'var(--laneB)' }}>Valve 2</div>
                <div style={{ color: 'var(--laneC)' }}>Valve 3</div>
              </div>
            </div>
          </section>

          {/* Bottom controls */}
          <footer className="px-3 pb-3">
            <Controls
              isLoaded={!!notes.length}
              running={running}
              onPlayPause={togglePlay}
              bpm={bpm}
              onBpm={setBpm}
              onFile={onFile}
              trackNames={trackNames}
              trackIndex={trackIndex}
              onTrackIndex={setTrackIndex}
              stats={stats}
              micNote={micNote}
            />
          </footer>

          {/* Settings menu */}
          <MenuPane
            open={menuOpen}
            onClose={() => setMenuOpen(false)}
            keyMap={keyMap}
            setKeyMap={setKeyMap}
            lookahead={lookahead}
            setLookahead={setLookahead}
            micEnabled={micEnabled}
            setMicEnabled={setMicEnabled}
            expertMode={expertMode}
            setExpertMode={setExpertMode}
          />
        </div>
      );
    }

    document.addEventListener('keydown', (e) => {
      const k = e.key?.toLowerCase?.();
      if (k === 'a' || k === 's' || k === 'd') { try { window.__pulseAmp && (window.__pulseAmp.value = 1); } catch { } }
    }, { passive: true });

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>

</html>
