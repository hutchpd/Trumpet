<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Trumpet Trainer (MVP)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- TailwindCSS Play CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            brand: {
              50: '#eef8ff',
              100: '#d9eeff',
              200: '#b7dfff',
              300: '#87c8ff',
              400: '#51a9ff',
              500: '#2b8eff',
              600: '#1e73f0',
              700: '#205dd0',
              800: '#214da8',
              900: '#203f85'
            }
          }
        }
      }
    }
  </script>
  <!-- React 18 UMD + Babel for in-browser JSX -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Tone.js + @tonejs/midi (UMD) + VexFlow (UMD v3) -->
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
  <script src="https://unpkg.com/@tonejs/midi@2.0.27/build/Midi.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vexflow/3.0.9/vexflow-min.js"></script>
  <script>
    window.VF = (window.Vex && window.Vex.Flow) || window.VexFlow || window.vexflow || null;
  </script>

  <style>
    :root {
      --bg: #0b1020;
      --fg: #d8e7ff;
      --laneA: #44e0a6;
      /* valve 1 */
      --laneB: #ffca3a;
      /* valve 2 */
      --laneC: #7cc6ff;
      /* valve 3 */
      --laneEdge: #143055;
      --grid: #0f2749;
      --hud: #6aa4ff;
    }

    .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,1px,1px); white-space:nowrap; border:0; }


    html,
    body,
    #root {
      height: 100dvh;
      min-height: 100dvh;
    }

    .take-marker { font: 700 12px ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto; paint-order: stroke; stroke: rgba(2,6,23,.8); stroke-width: 2; }
    .take-marker.correct { fill: #22c55e; }      /* emerald-500 */
    .take-marker.incorrect { fill: #ef4444; }    /* rose-500   */


    body {
      margin: 0;
      color: var(--fg);
      background:
        radial-gradient(1200px 600px at 50% 8%, #0f1b36 10%, rgba(15, 27, 54, .6) 30%, transparent 60%),
        radial-gradient(circle at 50% 10%, #0f1b36, var(--bg) 60%);
      overflow: hidden;
    }

    /* Subtle screen vignette */
    .vignette {
      position: fixed;
      inset: 0;
      box-shadow: inset 0 0 160px 80px rgba(0, 0, 0, .6)
    }

    .hitline {
      position: absolute;
      left: 0;
      right: 0;
      border-top: 2px dashed rgba(255, 255, 255, 0.55);
      pointer-events: none;
    }

    .note-glow {
      filter:
        drop-shadow(0 0 6px rgba(148, 221, 255, 0.9)) drop-shadow(0 0 12px rgba(148, 221, 255, 0.6));
    }

    .scrollbar-thin::-webkit-scrollbar {
      height: 6px;
      width: 6px;
    }

    .scrollbar-thin::-webkit-scrollbar-thumb {
      background: #94a3b8;
      border-radius: 9999px;
    }

    .hud {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      background: linear-gradient(180deg, rgba(9, 14, 28, .7), rgba(9, 14, 28, .25));
      border-top: 1px solid rgba(255, 255, 255, .06);
      backdrop-filter: blur(6px);
      border-radius: 12px;
    }

    .pill {
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .06);
      border: 1px solid rgba(255, 255, 255, .12);
      white-space: nowrap;
    }

    .transport {
      display: inline-flex;
      align-items: center;
      border-radius: 9999px;
      background: rgba(255, 255, 255, .06);
      border: 1px solid rgba(255, 255, 255, .12);
      box-shadow: 0 8px 24px rgba(0, 0, 0, .35), inset 0 1px 0 rgba(255, 255, 255, .05);
      overflow: hidden;
    }

    .transport .tbtn {
      width: 42px;
      height: 42px;
      display: grid;
      place-items: center;
      font-size: 18px;
      line-height: 1;
      transition: background-color .12s ease, filter .12s ease;
      user-select: none;
    }

    .transport .tbtn+.tbtn {
      border-left: 1px solid rgba(255, 255, 255, .08);
    }

    .transport .tbtn:hover {
      background: rgba(255, 255, 255, .06);
    }

    .transport .tbtn:disabled {
      opacity: .4;
    }

    .transport .tbtn.play {
      font-size: 19px;
      filter: drop-shadow(0 0 10px rgba(80, 180, 255, .25));
      background:
        radial-gradient(120% 140% at 50% -20%, rgba(80, 160, 255, .18), transparent 55%),
        rgba(255, 255, 255, .02);
    }


    .kbd {
      display: inline-grid;
      place-items: center;
      width: 22px;
      height: 22px;
      border: 1px solid rgba(255, 255, 255, .25);
      border-radius: 6px;
      background: rgba(0, 0, 0, .25);
      font-size: 12px;
      font-weight: 600;
    }

    .vf-host svg path[fill="black"],
    .vf-host svg rect[fill="black"] {
      fill: #cbd5e1 !important;
      /* slate-300 */
    }

    .vf-host svg path[stroke="black"],
    .vf-host svg rect[stroke="black"] {
      stroke: #cbd5e1 !important;
      /* slate-300 */
    }

    .vf-host svg .vf-stave path {
      stroke: #94a3b8;
    }

    /* slate-400 */
    .vf-host svg .vf-barline path {
      stroke: #94a3b8;
    }


    svg .vf-clef *,
    svg .vf-clef_treble *,
    svg g[class*="clef"] *,
    svg .vf-timeSig *,
    svg .vf-timesig *,
    svg .vf-time-signature *,
    svg g[class*="timesig"] * {
      fill: #cbd5e1 !important;
      stroke: #cbd5e1 !important;
    }

    /* brighten the staff lines a touch so the whole staff pops */
    svg .vf-stave path {
      stroke: #94a3b8;
      /* slate-400 */
    }

    /* barlines */
    svg .vf-barline path {
      stroke: #94a3b8;
    }

    @property --pulse {
      syntax: '<number>';
      inherits: false;
      initial-value: 0;
    }


    .grid-drift {
      position: relative;
      overflow: hidden;
      isolation: isolate;
      --beat: .5s;
      --cell: 44px;
      --pulse: 0;
      --pulseAmp: 1;
      --scanAlpha: .25;
    }

    .grid-drift::before {
      content: "";
      position: absolute;
      inset: -10% -5% 10% -5%;
      z-index: 0;
      pointer-events: none;
      transform-origin: center bottom;
      transform:
        perspective(900px) rotateX(calc(58deg + 2deg * var(--pulse) * var(--pulseAmp))) translateY(calc(6% + 1% * var(--pulse) * var(--pulseAmp))) scaleY(calc(1 + 0.28 * var(--pulse) * var(--pulseAmp)));
      background-image:
        repeating-linear-gradient(to bottom,
          rgba(120, 220, 255, 0.45) 0 2px,
          transparent 2px var(--cell)),
        repeating-linear-gradient(to right,
          rgba(114, 166, 233, 0.25) 0 1px,
          transparent 1px var(--cell));
      background-size: 100% 100%, 100% 100%;
      /* tempo-locked drift: one vertical cell per beat; slow lateral shimmer */
      animation:
        gridDriftY calc(var(--beat) * 1) linear infinite,
        gridDriftX calc(var(--beat) * 8) linear infinite,
        gridBreath var(--beat) cubic-bezier(.2, .9, .2, 1) infinite;
      /* pulse also brightens slightly */
      opacity: calc(0.28 + 0.66 * clamp(var(--pulse), 0, 1));
      filter: brightness(calc(1 + 0.65 * var(--pulse) * var(--pulseAmp))) saturate(1.25);
      mix-blend-mode: screen;
      mask-image: linear-gradient(to bottom, transparent 0%, black 18%, black 70%, transparent 100%);
      -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 18%, black 70%, transparent 100%);
      will-change: background-position, transform, opacity;
    }

    .grid-drift::after {
      content: "";
      position: absolute;
      inset: 0;
      z-index: 0;
      pointer-events: none;
      background:
        radial-gradient(1200px 420px at 50% 2%,
          rgba(255, 190, 255, 0.18), rgba(255, 120, 220, 0.10) 40%,
          rgba(255, 0, 140, 0.06) 60%, transparent 70%),
        linear-gradient(to bottom, rgba(255, 40, 140, 0.25), transparent 28%);
      opacity: .95;
      mix-blend-mode: screen;
      mask-image: linear-gradient(to bottom, rgba(0, 0, 0, .0) 0%, rgba(0, 0, 0, 1) 12%, rgba(0, 0, 0, 1) 80%, rgba(0, 0, 0, .0) 100%);
    }

    @keyframes gridBreath {
      0% {
        --pulse: .05;
      }

      30% {
        --pulse: 1;
      }

      100% {
        --pulse: .05;
      }
    }

    .grid-drift>canvas {
      position: relative;
      z-index: 1;
    }

    @keyframes gridDriftY {
      from {
        background-position: 0 0, 0 0;
      }

      to {
        background-position: 0 var(--cell), 0 0;
      }
    }

    @keyframes gridDriftX {
      from {
        background-position: 0 0, 0 0;
      }

      to {
        background-position: 0 0, var(--cell) 0;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .grid-drift::before { animation: none; }
    }
  </style>
</head>

<body class="text-slate-100 font-sans">
  <div id="root"></div>
  <div class="vignette pointer-events-none"></div>

  <script type="text/babel">

    const { useEffect, useRef, useState, useMemo, useCallback } = React;

    /******************************
     * Utilities
     ******************************/
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    // Simple debounce to avoid thrashing localStorage
    const debounce = (fn, ms = 120) => {
      let t;
      return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
    };

    // Valve bitmask helpers (1=valve1, 2=valve2, 4=valve3)
    const VALVE1 = 1, VALVE2 = 2, VALVE3 = 4;

    // Default key mapping
    const defaultKeyMap = { a: VALVE1, s: VALVE2, d: VALVE3 };

    /******************************
     * Settings persistence (localStorage)
     ******************************/
    const SETTINGS_KEY = 'tt:settings:v1';
    const DEFAULT_SETTINGS = {
      keyMap: { ...defaultKeyMap },
      lookahead: 3.5,
      micEnabled: false,
      expertMode: false,
      waitMode: false,
      transposeSemis: 2, // B♭
      showScore: true,
      showHighway: true,
      showNoteNames: false
    };

    const DEFAULT_OVERLAY = { showLastTake: true, overlayOpacity: 0.9};
    function loadSettings() {
      try {
        const raw = localStorage.getItem(SETTINGS_KEY);
        if (!raw) return { ...DEFAULT_SETTINGS };
        const parsed = JSON.parse(raw);
        // Shallow merge with sane defaults; ensure keyMap has all valves
        return {
          ...DEFAULT_SETTINGS,
          ...parsed,
          keyMap: { ...defaultKeyMap, ...(parsed.keyMap || {}) },
          showLastTake: parsed.showLastTake ?? DEFAULT_OVERLAY.showLastTake,
          overlayOpacity: parsed.overlayOpacity ?? DEFAULT_OVERLAY.overlayOpacity
        };
      } catch {
        return { ...DEFAULT_SETTINGS };
      }
    }
    const persistSettings = debounce((settings) => {
      try { localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); } catch { }
    }, 150);

    const ONSET_TOL_MS = 80, LATE_MISS_MS = 150;

    const noteToMask = {
      'F#3': VALVE1 | VALVE2 | VALVE3, 'Gb3': VALVE1 | VALVE2 | VALVE3,
      'G3': VALVE1 | VALVE3,
      'G#3': VALVE2 | VALVE3, 'Ab3': VALVE2 | VALVE3,
      'A3': VALVE1 | VALVE2,
      'A#3': VALVE1, 'Bb3': VALVE1,
      'B3': VALVE2,
      'C4': 0,
      'C#4': VALVE1 | VALVE2, 'Db4': VALVE1 | VALVE2,
      'D4': VALVE1 | VALVE3,
      'D#4': VALVE2 | VALVE3, 'Eb4': VALVE2 | VALVE3,
      'E4': VALVE1 | VALVE2,
      'F4': VALVE1,
      'F#4': VALVE2, 'Gb4': VALVE2,
      'G4': 0,
      'G#4': VALVE2 | VALVE3, 'Ab4': VALVE2 | VALVE3,
      'A4': VALVE1 | VALVE2,
      'A#4': VALVE1, 'Bb4': VALVE1,
      'B4': VALVE2,
      'C5': 0,
      'C#5': VALVE1 | VALVE2, 'Db5': VALVE1 | VALVE2,
      'D5': VALVE1 | VALVE3,
      'D#5': VALVE2 | VALVE3, 'Eb5': VALVE2 | VALVE3,
      'E5': VALVE1 | VALVE2,
      'F5': VALVE1,
      'F#5': VALVE2, 'Gb5': VALVE2,
      'G5': 0,
      'G#5': VALVE2 | VALVE3, 'Ab5': VALVE2 | VALVE3,
      'A5': VALVE1 | VALVE2,
      'A#5': VALVE1, 'Bb5': VALVE1,
      'B5': VALVE2,
      'C6': 0,
      'C#6': VALVE1 | VALVE2, 'Db6': VALVE1 | VALVE2,
      'D6': VALVE1 | VALVE3
    };
    function noteNameToMask(name) {
      const m = /^([A-Ga-g])([b#]?)(-?\d+)$/.exec(name || "");
      if (!m) return null;
      const key = m[1].toUpperCase() + (m[2] || '') + m[3];
      return (key in noteToMask) ? noteToMask[key] : null;
    }

    // --- Highway color by pitch *range* (E3..D6 split into 4 bins) ---
    const COLOR_LOW = '#22c55e';  // green
    const COLOR_MID = '#eab308';  // yellow
    const COLOR_HI = '#f97316';  // orange
    const COLOR_TOP = '#ef4444';  // red
    const MIDI_MIN = 52;  // E3
    const MIDI_MAX = 86;  // D6
    function colorForMidi(m) {
      const t = clamp((m - MIDI_MIN) / (MIDI_MAX - MIDI_MIN), 0, 1);
      if (t < 0.25) return COLOR_LOW;
      if (t < 0.50) return COLOR_MID;
      if (t < 0.75) return COLOR_HI;
      return COLOR_TOP;
    }


    // MIDI <-> note helpers
    const midiToFreq = (m) => 440 * Math.pow(2, (m - 69) / 12);
    const freqToMidi = (f) => Math.round(69 + 12 * Math.log2(f / 440));

    function midiToNoteName(midi) {
      if (midi == null || !isFinite(midi)) return "";
      const NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const n = Math.round(midi);
      const name = NAMES[((n % 12) + 12) % 12];
      const oct = Math.floor(n / 12) - 1;
      return `${name}${oct}`;
    }

    function midiToNameParts(midi) {
      const name = midiToNoteName(midi);               // e.g. "G#5"
      const m = /^([A-G])([#b]?)(-?\d+)$/.exec(name);
      if (!m) return { L: 'C', acc: '', oct: 4 };
      return { L: m[1], acc: m[2] || '', oct: +m[3] };
    }

    // Convert MIDI -> VexFlow key like "g#/4" plus accidental symbol
    function midiToVexKey(midi) {
      const name = midiToNoteName(midi);               // e.g. "G#5"
      const m = /^([A-G])([#b]?)(-?\d+)$/.exec(name);
      if (!m) return { key: 'c/4', acc: '' };
      const letter = m[1].toLowerCase();
      const acc = m[2] || '';
      const oct = m[3];
      return { key: `${letter}${acc}/${oct}`, acc };
    }


    const __LIDX = { C: 0, D: 1, E: 2, F: 3, G: 4, A: 5, B: 6 };
    function diatonicIndexFromMidi(midi) {
      const { L, oct } = midiToNameParts(midi);
      return oct * 7 + __LIDX[L];
    }
    function diatonicStepsBetween(m1, m2) {
      // how many staff positions from m1 -> m2 (ignoring accidentals)
      return diatonicIndexFromMidi(m2) - diatonicIndexFromMidi(m1);
    }
    function accidentalCharOfMidi(midi) {
      const { acc } = midiToNameParts(midi);
      return acc === '#' ? '♯' : acc === 'b' ? '♭' : '';
    }



    function noteNameToMidi(name) {
      const m = /^([A-Ga-g])([b#]?)(-?\d+)$/.exec(name || "");
      if (!m) return null;
      const L = m[1].toUpperCase();
      const acc = m[2] || '';
      const oct = parseInt(m[3], 10);
      const base = { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 }[L];
      if (base === undefined) return null;
      let semi = base + (acc === '#' ? 1 : acc === 'b' ? -1 : 0);
      return (oct + 1) * 12 + semi;
    }
    function centsDiff(freqA, freqB) {
      if (freqA <= 0 || freqB <= 0) return Infinity;
      return 1200 * Math.log2(freqA / freqB);
    }


    // Duration quantiser: measure-beats -> VexFlow duration for a given denominator.
    function quantizeBeats(beats, den = 4) {
      // Beats contributed by each symbol within this time signature.
      const beatsOf = (vex, dots = 0) => {
        const base = { w: den / 1, h: den / 2, q: den / 4, 8: den / 8, 16: den / 16, 32: den / 32 }[vex] || (den / 4);
        return base * (dots ? 1.5 : 1);
      };
      const symbols = ['w', 'h', 'q', '8', '16', '32'];
      let best = { diff: Infinity, vex: 'q', dots: 0 };
      for (const s of symbols) {
        const b0 = beatsOf(s, 0);
        const d0 = Math.abs(beats - b0);
        if (d0 < best.diff) best = { diff: d0, vex: s, dots: 0 };
        const b1 = beatsOf(s, 1);
        const d1 = Math.abs(beats - b1);
        if (d1 < best.diff) best = { diff: d1, vex: s, dots: 1 };
      }
      return { vex: best.vex, dots: best.dots };
    }


    // Helpers for engraving fit
    function beatsOfVex(vex, dots, den) {
      const base = { w: den / 1, h: den / 2, q: den / 4, 8: den / 8, 16: den / 16, 32: den / 32 }[vex] || (den / 4);
      return base * (dots ? 1.5 : 1);
    }
    function shortenQuant(q) {
      if (q.dots) return { vex: q.vex, dots: 0 };
      const order = ['w', 'h', 'q', '8', '16', '32'];
      const i = order.indexOf(q.vex);
      if (i < 0 || i === order.length - 1) return null;
      return { vex: order[i + 1], dots: 0 };
    }


    function secondsPerBeat(bpm) { return 60 / bpm; }
    function secondsPerMeasure(bpm, tsNum = 4, tsDen = 4) {
      const beatSeconds = secondsPerBeat(bpm) * (4 / tsDen); // adjust for denominator
      return tsNum * beatSeconds;
    }

    // Build lane events (one per lane per note) for canvas from MIDI notes
    function buildLaneEvents(notes, bpm, maskFromName, visualLookahead = 3.5) {
      const events = [];
      for (const n of notes) {
        const mask = maskFromName(n.name);
        // Skip notes that are out of our Yamaha map (no draw, no scoring)
        if (mask === null || mask === undefined) continue;
        const noteColor = colorForMidi(n.midi ?? freqToMidi(n.freq || 440));
        const lanes = [VALVE1, VALVE2, VALVE3];
        for (let i = 0; i < lanes.length; i++) {
          const bit = lanes[i];
          if (mask & bit) {
            events.push({
              lane: i, // 0,1,2
              start: n.time,
              end: n.time + n.duration,
              startTicks: n.ticks || 0,
              endTicks: (n.ticks || 0) + (n.durationTicks || 0),
              hit: false,
              judged: false,
              // render cache
              color: noteColor,
            });
          }
        }
        // If mask == 0 (open)
        if (mask === 0) {
          events.push({
            lane: -1,                // special: not tied to a valve lane
            open: true,
            start: n.time,
            end: n.time + n.duration,
            startTicks: n.ticks || 0,
            endTicks: (n.ticks || 0) + (n.durationTicks || 0),
            hit: false,
            judged: false,
            color: noteColor
          });
        }

      }
      // Sort by start time
      events.sort((a, b) => a.start - b.start || a.lane - b.lane);
      return events;
    }

    /******************************
     * Audio / Transport
     ******************************/
    function useToneSetup() {
      // Lead (selected track) & Backing (all other tracks)
      const leadSynthRef = useRef(null);
      const backingSynthRef = useRef(null);
      const limiterRef = useRef(null);
      const leadPartRef = useRef(null);
      const backingPartRef = useRef(null);
      const initedRef = useRef(false);
      const readyRef = useRef(false);

      const initAudio = useCallback(async () => {
        if (initedRef.current) return;
        await Tone.start();               // ensure user-gesture start

        // Single path: Synths -> Limiter -> Destination
        const limiter = new Tone.Limiter(-6).toDestination();

        const leadSynth = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: 'sawtooth' },
          envelope: { attack: 0.005, decay: 0.2, sustain: 0.15, release: 0.2 },
          volume: -8
        }).connect(limiter);

        // Backing: slightly softer, mellower timbre
        const backingSynth = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.3 },
          volume: -12
        }).connect(limiter);

        leadSynthRef.current = leadSynth;
        backingSynthRef.current = backingSynth;
        limiterRef.current = limiter;
        initedRef.current = true;
        readyRef.current = true;
      }, []);

      const setBackingMuted = useCallback((muted) => {
        try {
          if (leadSynthRef.current) {
            leadSynthRef.current.volume.value = muted ? -120 : -8;
            if (muted) leadSynthRef.current.releaseAll?.();
          }
          if (backingSynthRef.current) {
            backingSynthRef.current.volume.value = muted ? -120 : -12;
            if (muted) backingSynthRef.current.releaseAll?.();
          }
        } catch { }
      }, []);

      const scheduleLeadPart = useCallback(async (toneNotes, tickScale = 1) => {
        if (!toneNotes?.length) return;
        await initAudio();

        if (leadPartRef.current) {
          try { leadPartRef.current.dispose(); } catch { }
          leadPartRef.current = null;
        }
        const synth = leadSynthRef.current;
        const part = new Tone.Part((time, ev) => {
          if (ev.name && ev.duration) {
            synth.triggerAttackRelease(ev.name, ev.duration, time, ev.velocity ?? 0.8);
          } else if (ev.midi) {
            synth.triggerAttackRelease(midiToFreq(ev.midi), ev.duration, time, ev.velocity ?? 0.8);
          }
        }, toneNotes.map(n => ({
          // schedule in ticks (scaled from MIDI PPQ into Transport PPQ)
          time: Tone.Ticks((n.ticks || 0) * tickScale),
          name: n.name,
          duration: Tone.Ticks((n.durationTicks || 0) * tickScale),
          midi: n.midi,
          velocity: n.velocity
        })));
        part.loop = false;
        part.start(0);
        leadPartRef.current = part;
      }, [initAudio]);

      const scheduleBackingPart = useCallback(async (toneNotes, tickScale = 1) => {
        if (!toneNotes?.length) return;
        await initAudio();
        if (backingPartRef.current) {
          try { backingPartRef.current.dispose(); } catch { }
          backingPartRef.current = null;
        }
        const synth = backingSynthRef.current;
        const part = new Tone.Part((time, ev) => {
          if (ev.name && ev.duration) {
            synth.triggerAttackRelease(ev.name, ev.duration, time, ev.velocity ?? 0.6);
          } else if (ev.midi) {
            synth.triggerAttackRelease(midiToFreq(ev.midi), ev.duration, time, ev.velocity ?? 0.6);
          }
        }, toneNotes.map(n => ({
          time: Tone.Ticks(Math.max(0, (n.ticks || 0)) * tickScale),
          name: n.name,
          duration: Tone.Ticks(Math.max(1, (n.durationTicks || 1)) * tickScale),
          midi: n.midi,
          velocity: (n.velocity ?? 0.6) * 0.9
        })));
        part.loop = false;
        part.start(0);
        backingPartRef.current = part;
      }, [initAudio]);

      const clearLeadPart = useCallback(() => {
        if (leadPartRef.current) {
          try { leadPartRef.current.dispose(); } catch { }
          leadPartRef.current = null;
        }
      }, []);

      const clearBackingPart = useCallback(() => {
        if (backingPartRef.current) {
          try { backingPartRef.current.dispose(); } catch { }
          backingPartRef.current = null;
        }
      }, []);



      const stopAll = useCallback(() => {
        try {
          leadSynthRef.current?.releaseAll?.();
          backingSynthRef.current?.releaseAll?.();
        } catch { }
      }, []);


      useEffect(() => {
        return () => {
          try { leadPartRef.current?.dispose(); } catch { }
          try { backingPartRef.current?.dispose(); } catch { }
          try {
            leadSynthRef.current?.dispose();
            backingSynthRef.current?.dispose();
            limiterRef.current?.dispose();
          } catch { }
        };
      }, []);

      return {
        scheduleLeadPart,
        scheduleBackingPart,
        clearLeadPart,
        clearBackingPart,
        initAudio,
        readyRef,
        stopAll,
        setBackingMuted
      };
    }

    /******************************
     * VexFlow ScoreDisplay (scroll + seek + cursor)
     ******************************/
    function ScoreDisplay({
      notes,
      bpm,
      timeSig = [4, 4],
      ppq = 480,
      currentTicks,
      running,
      width,
      micEnabled, micNote, expertMode, toleranceCents = 35,
      height,
      showNoteNames = false,
      measuresPerRow = 2,
      onSeekTicks,
      lastTake = [],
      showLastTake = true,
      overlayOpacity = 0.9,
    }) {
      const scrollRef = React.useRef(null);     // scrollable viewport
      const hostRef = React.useRef(null);     // where VexFlow SVG mounts
      const overlayRef = React.useRef(null);     // absolute overlay for cursor
      const micHostRef = React.useRef(null); // seperates SVG overlay for mic voice
      const takeHostRef = React.useRef(null); // layer for last-take markers
      const draggingRef = React.useRef(false);
      const dragStart = React.useRef({ y: 0, top: 0 });
      const lastMeasureRef = React.useRef(-1);    // autoscroll per bar, not per row
      const noteElsRef = React.useRef([]);        // cache note <g> elements for fast highlight
      const domNotesByMeasureRef = React.useRef([]); // Array< Array<{el, x, cx}> >
      const orderByMeasureRef = React.useRef([]); // Array< {measure, startTicks} >
      const expectedCursorRef = React.useRef(0); // start at first note
      const stavesRef = React.useRef([]);  // keep VexFlow stave per measure

      React.useEffect(() => {
        expectedCursorRef.current = 0;
      }, [notes]);


      // Pre-compute measures & ticks
      const measureData = React.useMemo(() => {
        const [num, den] = timeSig || [4, 4];
        const measures = new Map();
        const ticksToBeats = (ticks) => (ticks / (ppq || 480)) * (4 / den);
        const beatsPerMeasure = num;
        for (const n of notes || []) {
          const startBeats = ticksToBeats(n.ticks || 0);
          const durBeats = ticksToBeats(n.durationTicks || 0);
          const m = Math.floor(startBeats / beatsPerMeasure);
          const entry = {
            name: n.name,
            beats: Math.max(durBeats, 0.0001),
            startTicks: n.ticks || 0,
            endTicks: (n.ticks || 0) + (n.durationTicks || 0)
          };
          if (!measures.has(m)) measures.set(m, []);
          measures.get(m).push(entry);
        }
        const maxMeasureIdx = measures.size ? Math.max(...measures.keys()) : 0;
        return { measures, maxMeasureIdx, beatsPerMeasure };
      }, [notes, timeSig, ppq]);

      // Layout constants (kept in sync with draw routine)
      const paddingX = 20;
      const systemTop = 8;
      const systemGap = 28;
      const rowsCount = React.useMemo(() =>
        Math.ceil((measureData.maxMeasureIdx + 1) / measuresPerRow), [measureData, measuresPerRow]);
      const rowHeight = React.useMemo(() => (height - systemTop * 2 - systemGap) / 2, [height, systemTop, systemGap]);
      const systemWidth = React.useMemo(() => width - paddingX * 2, [width, paddingX]);
      const measureWidth = React.useMemo(() => systemWidth / measuresPerRow, [systemWidth, measuresPerRow]);
      const contentHeight = React.useMemo(() =>
        systemTop + rowsCount * (rowHeight + systemGap) - systemGap + 16, [rowsCount, rowHeight, systemGap, systemTop]);

      // Keep rects for each measure (x,y,w,h)
      const rectsRef = React.useRef([]);
      const ticksPerMeasure = React.useMemo(() => {
        const [num, den] = timeSig || [4, 4];
        return (ppq || 480) * num * (4 / den);
      }, [timeSig, ppq]);

      // expose for overlay renderer
      React.useImperativeHandle(overlayApiRef, () => ({ rectsRef, orderByMeasureRef, domNotesByMeasureRef }), []);

      // Draw whole score
      React.useEffect(() => {
        const el = hostRef.current;
        if (!el) return;
        const VF = window.VF;
        if (!VF) return;
        el.innerHTML = '';

        const [num, den] = timeSig || [4, 4];
        if (!el.id) el.id = 'vf_score_' + Math.random().toString(36).slice(2);
        const factory = new VF.Factory({
          renderer: { elementId: el.id, width, height: contentHeight, backend: VF.Renderer.Backends.SVG }
        });
        stavesRef.current = [];
        const score = factory.EasyScore();
        const NOTE_COLOR = '#cbd5e1';

        const beatsPerMeasure = num;
        const toVexKey = (name) => {
          const m = /^([A-Ga-g])([b#]?)(-?\d+)$/.exec(name || 'C4');
          if (!m) return 'c/4';
          const letter = m[1].toLowerCase();
          const acc = m[2] || '';
          const oct = m[3];
          return `${letter}${acc}/${oct}`;
        };

        const prettyNoteName = (name) => {
          const m = /^([A-Ga-g])([b#]?)(-?\d+)$/.exec(name || '');
          if (!m) return '';
          const L = m[1].toUpperCase();
          const acc = m[2] === '#' ? '♯' : (m[2] === 'b' ? '♭' : '');
          const oct = m[3];
          return `${L}${acc}${oct}`;
        };

        // Build rects for each measure (for cursor & seeking)
        rectsRef.current = [];
        const totalMeasures = measureData.maxMeasureIdx + 1;
        const rows = rowsCount;

        orderByMeasureRef.current = new Array(totalMeasures).fill(0).map(() => []);


        for (let mIdx = 0; mIdx < totalMeasures; mIdx++) {
          const row = Math.floor(mIdx / measuresPerRow);
          const col = mIdx % measuresPerRow;
          const sys = factory.System({
            x: paddingX + col * measureWidth,
            y: systemTop + row * (rowHeight + systemGap),
            width: measureWidth,
            spaceBetweenStaves: 0
          });
          const entries = measureData.measures.get(mIdx) || [];
          const tickables = [];
          const measureNoteOrder = [];
          let used = 0;
          let hadNotes = false;
          for (const e of entries) {
            let q = quantizeBeats(e.beats, den);
            let b = beatsOfVex(q.vex, q.dots, den);
            while (used + b > beatsPerMeasure + 1e-6) {
              const next = shortenQuant(q);
              if (!next) { b = 0; break; }
              q = next; b = beatsOfVex(q.vex, q.dots, den);
            }
            if (b > 1e-6) {
              const n = factory.StaveNote({ keys: [toVexKey(e.name || 'C4')], duration: q.vex });
              n.setStyle({ fillStyle: NOTE_COLOR, strokeStyle: NOTE_COLOR });
              const accMatch = /^([A-Ga-g])([b#]?)(-?\d+)$/.exec(e.name || '');
              const accSym = accMatch ? (accMatch[2] || '') : '';
              if (accSym) n.addAccidental(0, new VF.Accidental(accSym));
              if (q.dots) n.addDot(0);

               if (showNoteNames) {
                 const ann = new VF.Annotation(prettyNoteName(e.name || ''))
                   .setFont('ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto', 10, 'normal')
                   .setVerticalJustification(VF.Annotation.VerticalJustify.BOTTOM);
                 n.addAnnotation(0, ann);
               }

              // record order for later DOM mapping (ticks -> note index in this measure)
              const midiVal = noteNameToMidi(e.name);
              measureNoteOrder.push({ startTicks: e.startTicks || 0, midi: midiVal ?? NaN });

              tickables.push(n);
              used += b;
              hadNotes = true;
              if (used >= beatsPerMeasure - 1e-6) break;
            }
          }
          const addRestsToFill = (rem) => {
            const order = ['w', 'h', 'q', '8', '16', '32'];
            while (rem > 1e-6) {
              let placed = false;
              for (const s of order) {
                const sb = beatsOfVex(s, 0, den);
                if (sb <= rem + 1e-6) {
                  const r = factory.StaveNote({ keys: ['b/4'], duration: s + 'r' });
                  r.setStyle?.({ fillStyle: NOTE_COLOR, strokeStyle: NOTE_COLOR });
                  tickables.push(r); rem -= sb; placed = true; break;
                }
              }
              if (!placed) break;
            }
          };
          const remaining = beatsPerMeasure - used;
          if (remaining > 1e-6) {
            if (hadNotes) addRestsToFill(remaining);
            else tickables.push(new VF.GhostNote({ duration: 'w' }));
          }
          if (hadNotes) tickables.unshift(new VF.GhostNote({ duration: '16' }));
          const voice = factory.Voice({ time: `${num}/${den}` }); voice.setStrict?.(false);
          if (VF.Voice?.Mode && voice.setMode) voice.setMode(VF.Voice.Mode.SOFT);
          voice.addTickables(tickables);
          const stave = sys.addStave({ voices: [voice] });
          stavesRef.current[mIdx] = stave;
          if (mIdx === 0) stave.addClef('treble').addTimeSignature(`${num}/${den}`);
          orderByMeasureRef.current[mIdx] = measureNoteOrder;

          // record rect
          rectsRef.current[mIdx] = {
            x: paddingX + col * measureWidth,
            y: systemTop + row * (rowHeight + systemGap),
            w: measureWidth,
            h: rowHeight
          };
        }

        factory.draw();

        try {
          const svg = el.querySelector('svg');
          domNotesByMeasureRef.current = new Array(measureData.maxMeasureIdx + 1)
            .fill(0)
            .map(() => []);

          if (svg && rectsRef.current.length) {
            const all = Array.from(svg.querySelectorAll('g.vf-stavenote'));
            const isRest = (g) => !!g.querySelector('[class*="rest"]');

            for (const g of all) {
              if (isRest(g)) continue; // skip rests entirely
              const bb = g.getBBox();
              const cx = bb.x + bb.width / 2;

              // assign to the measure whose rect contains the center x (and roughly overlaps in y)
              for (let m = 0; m < rectsRef.current.length; m++) {
                const r = rectsRef.current[m];
                if (!r) continue;
                const withinX = cx >= r.x && cx <= (r.x + r.w);
                const withinY = (bb.y < r.y + r.h + 60) && ((bb.y + bb.height) > r.y - 60);
                if (withinX && withinY) {
                  domNotesByMeasureRef.current[m].push({ el: g, x: bb.x, cx });
                  break;
                }
              }
            }

            // Normalize each measure's list: sort left→right and trim to musical count
            for (let m = 0; m < domNotesByMeasureRef.current.length; m++) {
              const list = domNotesByMeasureRef.current[m];
              const ord = orderByMeasureRef.current[m] || [];
              list.sort((a, b) => a.x - b.x);
              if (ord.length && list.length > ord.length) {
                domNotesByMeasureRef.current[m] = list.slice(0, ord.length);
              }
            }
          }

        } catch { }

        // Clear last-take layer whenever we redraw staff
        if (takeHostRef.current) takeHostRef.current.innerHTML = '';

        try {
          const svg = el.querySelector('svg');
          if (svg) {
            const UI = '#cbd5e1';      // your slate-300
            const STAFF = '#94a3b8';   // your slate-400

            const fillSel = [
              'path[fill="black"]',
              'path[fill="#000"]',
              'path[fill="rgb(0, 0, 0)"]',
              'rect[fill="black"]',
              'rect[fill="#000"]',
              'rect[fill="rgb(0, 0, 0)"]'
            ].join(',');
            const strokeSel = [
              'path[stroke="black"]',
              'path[stroke="#000"]',
              'path[stroke="rgb(0, 0, 0)"]',
              'rect[stroke="black"]',
              'rect[stroke="#000"]',
              'rect[stroke="rgb(0, 0, 0)"]'
            ].join(',');

            svg.querySelectorAll(fillSel).forEach(n => n.setAttribute('fill', UI));
            svg.querySelectorAll(strokeSel).forEach(n => n.setAttribute('stroke', UI));

            // Staff lines & barlines a touch dimmer than glyphs:
            svg.querySelectorAll('.vf-stave path, .vf-barline path').forEach(n => n.setAttribute('stroke', STAFF));
          }
        } catch { }



        // Normalise staff, clef, time-signature colours
        try {
          const svg = el.querySelector('svg');
          const UI_COLOR = '#cbd5e1';
          if (!svg) return;
          const sets = [
            '.vf-clef *',
            '.vf-clef_treble *',
            'g[class*="clef"] *',
            '.vf-timeSig *',
            '.vf-timesig *',
            '.vf-time-signature *',
            'g[class*="timesig"] *'
          ];
          sets.forEach(sel => {
            svg.querySelectorAll(sel).forEach(n => {
              n.setAttribute?.('fill', UI_COLOR);
              n.setAttribute?.('stroke', UI_COLOR);
            });
          });
          // Optional: brighten staff & barlines via JS too.
          svg.querySelectorAll('.vf-stave path, .vf-barline path').forEach(n => {
            n.setAttribute?.('stroke', '#94a3b8');
          });
        } catch {
          /* no-op */
        }
      }, [measureData, timeSig, width, height, ppq, contentHeight, measureWidth, rowHeight, systemGap, systemTop, measuresPerRow, rowsCount]);

      // Update yellow cursor + autoscroll once per *row* (snap row to top)
      React.useEffect(() => {
        const overlay = overlayRef.current;
        const scroller = scrollRef.current;
        if (!overlay || !scroller || !rectsRef.current.length) return;

        // Where is the cursor inside the current measure?
        const idx = Math.max(0, Math.floor((currentTicks || 0) / (ticksPerMeasure || 1)));
        const frac = ((currentTicks || 0) % (ticksPerMeasure || 1)) / (ticksPerMeasure || 1);
        const rect = rectsRef.current[idx] || rectsRef.current[rectsRef.current.length - 1];
        const x = (rect?.x || 0) + frac * (rect?.w || 0);
        const y = rect?.y || 0;
        const h = rect?.h || 0;
        overlay.style.transform = `translate(${Math.round(x)}px, ${Math.round(y)}px)`;
        overlay.style.height = `${Math.round(h)}px`;

        // Only scroll when the *row* changes (not every measure)
        const rowNow = Math.floor(idx / (measuresPerRow || 1));
        const rowPrev = Math.floor((lastMeasureRef.current >= 0 ? lastMeasureRef.current : 0) / (measuresPerRow || 1));
        if (running && !draggingRef.current && rowNow !== rowPrev) {
          lastMeasureRef.current = idx;
          const firstMeasureOfRow = rowNow * (measuresPerRow || 1);
          const rowRect = rectsRef.current[firstMeasureOfRow];
          const targetTop = Math.max(0, (rowRect?.y || 0) - 8);

          // Prefer native smooth scroll; fallback to RAF if needed
          try {
            scroller.scrollTo({ top: targetTop, behavior: 'smooth' });
          } catch {
            const startTop = scroller.scrollTop;
            const dist = targetTop - startTop;
            const dur = 250;
            const t0 = performance.now();
            const ease = (t) => (t < .5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2);
            let raf;
            const step = () => {
              const p = Math.min(1, (performance.now() - t0) / dur);
              scroller.scrollTop = startTop + dist * ease(p);
              if (p < 1) raf = requestAnimationFrame(step);
            };
            raf = requestAnimationFrame(step);
            return () => cancelAnimationFrame(raf);
          }
        } else {
          lastMeasureRef.current = idx;
        }
      }, [currentTicks, ticksPerMeasure, running, measuresPerRow]);



      const getExpectedNoteAtTicks = React.useCallback((ticksNow) => {
        const arr = notes || [];
        if (!arr.length) return null;
        let i = (typeof expectedCursorRef.current === 'number' ? expectedCursorRef.current : 0);
        if (i < 0) i = 0;
        if (i >= arr.length) i = arr.length - 1;
        while (i < arr.length && ((arr[i].ticks || 0) + (arr[i].durationTicks || 0)) <= ticksNow) i++;
        while (i > 0 && (arr[i].ticks || 0) > ticksNow) i--;
        expectedCursorRef.current = i;
        const n = arr[i];
        if (!n) return null;
        const s = n.ticks || 0, e = s + (n.durationTicks || 0);
        if (s <= ticksNow && ticksNow < e) return n;
        return null;
      }, [notes]);

      React.useEffect(() => {
        const VF = window.VF;
        const host = micHostRef.current;
        if (!host || !VF) return;
        // Clear previous overlay
        host.innerHTML = '';
        if (!micEnabled || !micNote) return;

        const t = currentTicks || 0;
        // Which measure are we in?
        const mIdx = Math.max(0, Math.floor(t / (ticksPerMeasure || 1)));
        const rect = rectsRef.current[mIdx];
        const stave = stavesRef.current[mIdx];
        if (!rect || !stave) return;

        // Cursor horizontal position inside this measure
        const frac = ((t % (ticksPerMeasure || 1)) / (ticksPerMeasure || 1));
        const cursorX = rect.x + frac * rect.w;

        // Decide green/red using same tolerance (unless expert mode)
        let good = false;
        const expected = getExpectedNoteAtTicks(t);
        const expMidi = expected ? (expected.midi ?? noteNameToMidi(expected.name)) : null;
        if (Number.isFinite(expMidi)) {
          if (micNote.midi === expMidi) {
            good = true;
          } else if (!expertMode) {
            const targetFreq = midiToFreq(expMidi);
            const diff = centsDiff(micNote.freq, targetFreq);
            good = Math.abs(diff) <= (toleranceCents || 35);
          }
        }
        const color = good ? '#22c55e' : '#ef4444';

        // Build a tiny SVG with a single VexFlow note placed at cursorX
        if (!host.id) host.id = 'vf_mic_' + Math.random().toString(36).slice(2);
        const factory = new VF.Factory({
          renderer: { elementId: host.id, width, height: contentHeight, backend: VF.Renderer.Backends.SVG }
        });
        const ctx = factory.getContext();

        const { key, acc } = midiToVexKey(micNote.midi);
        const micStave = new VF.Stave(rect.x, rect.y, rect.w); // geometry only; we won't draw it
        micStave.setContext(ctx);

        const n = new VF.StaveNote({ keys: [key], duration: 'q', clef: 'treble' });
        if (acc) n.addAccidental(0, new VF.Accidental(acc));
        n.setStyle({ fillStyle: color, strokeStyle: color });
        n.setStave(micStave);
        n.setContext(ctx);
        // Always attach a TickContext before preFormat; set X on the TickContext.
        const tc = new VF.TickContext();
        // VexFlow draws at (stave.getX() + tickContext.getX()).
        // cursorX is absolute, so make tickContext X relative to this stave.
        tc.setX(cursorX - micStave.getX()).setPadding(0);
        n.setTickContext(tc);
        n.preFormat();

        n.draw();
      }, [currentTicks, micEnabled, micNote, expertMode, toleranceCents, ticksPerMeasure, getExpectedNoteAtTicks, contentHeight]);


      // Drag to scroll + click to seek
      const onMouseDown = (e) => {
        draggingRef.current = true;
        dragStart.current = { y: e.clientY, top: scrollRef.current?.scrollTop || 0 };
        scrollRef.current?.classList.add('cursor-grabbing');
      };
      const onMouseMove = (e) => {
        if (!draggingRef.current) return;
        const dy = e.clientY - dragStart.current.y;
        const sc = scrollRef.current;
        if (sc) sc.scrollTop = dragStart.current.top - dy;
      };
      const endDrag = () => {
        draggingRef.current = false;
        scrollRef.current?.classList.remove('cursor-grabbing');
      };
      const onClick = (e) => {
        if (Math.abs((scrollRef.current?.scrollTop || 0) - dragStart.current.top) > 2) return;
        const host = hostRef.current;
        if (!host || !rectsRef.current.length) return;
        const bounds = host.getBoundingClientRect();
        const x = e.clientX - bounds.left;
        const y = e.clientY - bounds.top;
        const col = clamp(Math.floor((x - paddingX) / measureWidth), 0, measuresPerRow - 1);
        const row = clamp(Math.floor((y - systemTop) / (rowHeight + systemGap)), 0, rowsCount - 1);
        const idx = clamp(row * measuresPerRow + col, 0, rectsRef.current.length - 1);
        const rect = rectsRef.current[idx];
        if (!rect) return;
        const frac = clamp((x - rect.x) / rect.w, 0, 1);
        const targetTicks = Math.round(idx * ticksPerMeasure + frac * ticksPerMeasure);
        onSeekTicks && onSeekTicks(targetTicks);
      };

      React.useEffect(() => {
        // Render markers only when asked, only when not running
        const host = takeHostRef.current;
        if (!host) return;
        host.innerHTML = '';
        if (!showLastTake || running || !Array.isArray(lastTake) || !lastTake.length) return;
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', String(width));
        svg.setAttribute('height', String(contentHeight));
        svg.setAttribute('viewBox', `0 0 ${width} ${contentHeight}`);
        svg.setAttribute('aria-hidden', 'true');
        svg.style.opacity = String(clamp(overlayOpacity ?? 1, 0, 1));
        const g = document.createElementNS(svg.namespaceURI, 'g');
        const frag = document.createDocumentFragment();
        // place one marker per expected note
        for (const item of lastTake) {
          const { measure, idxInMeasure, result, timingErrorMs } = item.__loc || {};
          if (measure == null || idxInMeasure == null) continue;
          const list = (domNotesByMeasureRef.current[measure] || []);
          const h = list[idxInMeasure]; if (!h) continue;
          const x = h.cx, y = (rectsRef.current[measure]?.y || 0) + 20; // roughly above notehead center
          // marker: ✔/✖ plus small chevron for early/late
          const txt = document.createElementNS(svg.namespaceURI, 'text');
          txt.setAttribute('x', Math.round(x)); txt.setAttribute('y', Math.round(y));
          txt.setAttribute('text-anchor', 'middle'); txt.setAttribute('class', `take-marker ${result === 'hit' || result === 'partial' ? 'correct' : 'incorrect'}`);
          txt.textContent = (result === 'hit' || result === 'partial') ? '✔' : '✖';
          // timing chevron
          if (Number.isFinite(timingErrorMs) && Math.abs(timingErrorMs) >= 5) {
            const chev = document.createElementNS(svg.namespaceURI, 'text');
            chev.setAttribute('x', Math.round(x + (timingErrorMs < 0 ? -12 : 12)));
            chev.setAttribute('y', Math.round(y));
            chev.setAttribute('text-anchor', timingErrorMs < 0 ? 'end' : 'start');
            chev.setAttribute('class', `take-marker ${result === 'hit' || result === 'partial' ? 'correct' : 'incorrect'}`);
            chev.textContent = timingErrorMs < 0 ? '‹' : '›';
            g.appendChild(chev);
          }
          g.appendChild(txt);
        }
        svg.appendChild(g);
        frag.appendChild(svg);
        host.appendChild(frag);
      }, [lastTake, showLastTake, overlayOpacity, running, width, contentHeight]);


      return (
        <div className="w-full h-full relative">
          <div
            ref={scrollRef}
            className="absolute inset-0 overflow-y-auto overflow-x-hidden select-none cursor-grab"
            onMouseDown={onMouseDown}
            onMouseMove={onMouseMove}
            onMouseLeave={endDrag}
            onMouseUp={endDrag}
            onClick={onClick}
          >
            <div style={{ position: 'relative', width: `${width}px`, height: `${contentHeight}px` }}>
              <div ref={hostRef} className="vf-host absolute inset-0" style={{ zIndex: 1 }} />
              <div ref={micHostRef} className="absolute inset-0 pointer-events-none" style={{ zIndex: 2 }} />
              <div ref={takeHostRef} className="absolute inset-0 pointer-events-none" style={{ zIndex: 3 }} />
              <div
                ref={overlayRef}
                style={{
                  position: 'absolute', left: 0, top: 0, width: '2px',
                  background: '#fde047',
                  boxShadow: '0 0 0 2px rgba(253,224,71,.25), 0 0 12px rgba(253,224,71,.6)',
                  pointerEvents: 'none',
                  zIndex: 4
                }}
              />
            </div>
          </div>
        </div>
      );
    }

    const overlayApiRef = React.createRef();

    /******************************
     * Canvas Note Highway
     ******************************/
    function NoteHighway({
      laneEvents,
      keyStateMask,
      width,
      height,
      lookahead = 3.5,
      onHitJudgement,
      running,
      currentTicks, 
      bpm,
      ppq = 480,
      onTouchMaskChange,
      micNote,
      micEnabled,
      tunerTargetMidi,
      tunerToleranceCents = 15
    }) {

      const canvasRef = useRef(null);
      const rafRef = useRef(null);
      const tickRef = useRef(0);
      useEffect(() => { tickRef.current = currentTicks || 0; }, [currentTicks]);
      const activePointersRef = useRef(new Map());

      const hitYRatio = 0.88;
      const vanishYRatio = 0.18;
      const tunerYRatio = (hitYRatio + vanishYRatio) * 0.5;
      const isNarrow = width < 420;
      const totalWidthFrac = isNarrow ? 0.70 : 0.80;
      const laneGapAtHit = isNarrow ? Math.max(12, Math.round(width * 0.04)) : 28;
      const minLaneWidthFar = 0;
      const gamma = 1.15;

      const [frame, setFrame] = useState(0); // force updates on resize

       const micNoteRef = useRef(null);
       const targetMidiRef = useRef(null);
       const micEnabledRef = useRef(false);
       useEffect(() => { micNoteRef.current = micNote; }, [micNote]);
       useEffect(() => { targetMidiRef.current = tunerTargetMidi; }, [tunerTargetMidi]);
       useEffect(() => { micEnabledRef.current = !!micEnabled; }, [micEnabled]);


      // Smooth visibility for the tuner (fade in/out based on mic activity & target note)
      const tunerAlphaRef = useRef(0);
      const lastVoiceSecRef = useRef(0);

      // Resize canvas to DPR
      const resizeCanvas = useCallback(() => {
        const c = canvasRef.current;
        if (!c) return;
        const dpr = window.devicePixelRatio || 1;
        // Read the actual on-screen size the canvas is occupying
        const cssW = Math.round(c.clientWidth || width || 0);
        const cssH = Math.round(c.clientHeight || height || 0);
        c.width  = Math.max(1, Math.round(cssW * dpr));
        c.height = Math.max(1, Math.round(cssH * dpr));
        const ctx = c.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        setFrame(f => f + 1);
      }, [width, height]);

      useEffect(() => {
        resizeCanvas();
        const onResize = () => resizeCanvas();
        window.addEventListener('resize', onResize);
        return () => window.removeEventListener('resize', onResize);
      }, [resizeCanvas]);

      const recomputeTouchUnion = useCallback(() => {
        let m = 0;
        activePointersRef.current.forEach(v => { m |= v; });
        onTouchMaskChange && onTouchMaskChange(m);
      }, [onTouchMaskChange]);
      const yToU = useCallback((y, hitY, vanishY) => {
        const r = (y - vanishY) / Math.max(1, (hitY - vanishY));
        return clamp(Math.pow(clamp(r, 0, 1), 1 / gamma), 0, 1);
      }, []);
      const laneMaskAtPoint = useCallback((x, y) => {
        const hitY = Math.round(height * hitYRatio);
        const vanishY = Math.round(height * vanishYRatio);
        const centerX = width / 2;
        const usableWidthAtHit = Math.min(width * totalWidthFrac, 560);
        const laneWidthAtHit = (usableWidthAtHit - laneGapAtHit * 2) / 3;
        const startLeftAtHit = centerX - usableWidthAtHit / 2;
        const laneCenterAtHit = (i) => startLeftAtHit + i * (laneWidthAtHit + laneGapAtHit) + laneWidthAtHit / 2;
        const u = yToU(y, hitY, vanishY);
        const laneGeom = (i) => {
          const cxHit = laneCenterAtHit(i);
          const cx = centerX + (cxHit - centerX) * u;
          const w = minLaneWidthFar + (laneWidthAtHit - minLaneWidthFar) * u;
          return [cx, w];
        };
        let mask = 0;
        [[0, VALVE1], [1, VALVE2], [2, VALVE3]].forEach(([i, bit]) => {
          const [cx, w] = laneGeom(i);
          if (x >= (cx - w / 2) && x <= (cx + w / 2)) mask |= bit;
        });
        return mask;
      }, [height, width]);


      useEffect(() => {
        const c = canvasRef.current;
        if (!c) return;
        const ctx = c.getContext('2d');

        const laneCount = 3;
        const hitY = Math.round(height * hitYRatio);
        const vanishY = Math.round(height * vanishYRatio);
        const centerX = width / 2;
        const usableWidthAtHit = Math.min(width * totalWidthFrac, 560);
        const laneWidthAtHit = (usableWidthAtHit - laneGapAtHit * (laneCount - 1)) / laneCount;
        const startLeftAtHit = centerX - usableWidthAtHit / 2;
        const laneCenterAtHit = (i) => (
          startLeftAtHit + i * (laneWidthAtHit + laneGapAtHit) + laneWidthAtHit / 2
        );
        const laneColors = ['#23f5b0', '#ffd33d', '#8ae1ff']; // per-valve
        const receptorRadius = isNarrow ? 9 : 11;

        // Project a param u in [0..1] (0=far, 1=at hit line) to y coordinate
        const uToY = (u) => {
          const eased = Math.pow(u, gamma);
          return vanishY + (hitY - vanishY) * eased;
        };
        // For a lane i and progress u, return [cx, w] at that depth
        const laneGeom = (i, u) => {
          const cxHit = laneCenterAtHit(i);
          const cx = centerX + (cxHit - centerX) * u; // converge to center at distance
          const w = minLaneWidthFar + (laneWidthAtHit - minLaneWidthFar) * u;
          return [cx, w];
        };

        function drawTopRoundedTrapezoid(xSL, xSR, yStart, xEL, xER, yEnd /* rTop unused */) {
          ctx.beginPath();
          ctx.moveTo(xSL, yStart);     // top-left
          ctx.lineTo(xSR, yStart);     // top-right (dead flat)
          ctx.lineTo(xER, yEnd);       // down right side
          ctx.lineTo(xEL, yEnd);       // bottom
          ctx.closePath();
        }




        function drawBackground() {
          ctx.clearRect(0, 0, width, height);
          ctx.shadowColor = 'rgba(0,190,255,0.25)';
          ctx.shadowBlur = 8;
          ctx.fillStyle = 'rgba(10,20,38,0.75)';
          ctx.fillRect(0, 0, width, height);
          // Perspective “rails” per lane
          for (let i = 0; i < laneCount; i++) {
            ctx.beginPath();
            // far
            const u0 = 0;
            const y0 = uToY(u0);
            const [cx0, w0] = laneGeom(i, u0);
            // near
            const u1 = 1;
            const y1 = uToY(u1);
            const [cx1, w1] = laneGeom(i, u1);
            ctx.moveTo(cx0 - w0 / 2, y0);
            ctx.lineTo(cx1 - w1 / 2, y1);
            ctx.lineTo(cx1 + w1 / 2, y1);
            ctx.lineTo(cx0 + w0 / 2, y0);
            ctx.closePath();
            ctx.fillStyle = 'rgba(10,20,38,0.88)';
            ctx.fill();
            ctx.lineWidth = 1.25;
            ctx.strokeStyle = 'rgba(40,120,255,0.35)';
            ctx.stroke();
          }

          // Hit line & receptors
          ctx.strokeStyle = 'rgba(150,183,255,0.5)';
          ctx.lineWidth = 2;
          ctx.setLineDash([6, 6]);
          ctx.beginPath(); ctx.moveTo(0, hitY); ctx.lineTo(width, hitY); ctx.stroke();
          ctx.setLineDash([]);

          for (let i = 0; i < laneCount; i++) {
            const [cx, w] = laneGeom(i, 1);
            const bit = (i === 0 ? VALVE1 : (i === 1 ? VALVE2 : VALVE3));
            const pressed = !!(keyStateMask & bit);
            const halo = pressed ? 10 : 6;
            ctx.beginPath();
            ctx.arc(cx, hitY, receptorRadius + (pressed ? 2 : 0), 0, Math.PI * 2);
            ctx.fillStyle = pressed ? laneColors[i] : 'rgba(16,28,50,0.92)';
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = pressed ? 'rgba(255,255,255,0.95)' : 'rgba(148,163,184,0.28)';
            ctx.stroke();
            if (pressed) {
              ctx.shadowColor = laneColors[i];
              ctx.shadowBlur = halo * 0.7;
              ctx.beginPath();
              ctx.arc(cx, hitY, receptorRadius + 10, 0, Math.PI * 2);
              ctx.strokeStyle = laneColors[i];
              ctx.stroke();
              ctx.shadowBlur = 0;
              const t = performance.now() / 600;
              ctx.setLineDash([4, 6]);
              ctx.beginPath();
              ctx.arc(cx, hitY, receptorRadius + 14, t, t + Math.PI * 1.2);
              ctx.strokeStyle = 'rgba(255,255,255,0.55)'; ctx.lineWidth = 1;
              ctx.stroke(); ctx.setLineDash([]);

            }
          }
        }


        // Pre-calc to speed drawing
        const secToTicks = (sec) => (ppq * (bpm / 60)) * sec;
        let lookaheadTicks = secToTicks(lookahead);

        function drawNotes() {
          const nowT = tickRef.current;
          // recompute in case BPM changed since effect mount
          lookaheadTicks = secToTicks(lookahead);
          const startWindow = nowT;
          const endWindow = nowT + lookaheadTicks;

          ctx.shadowBlur = 0;

          for (const ev of laneEvents) {
            // Skip those far away (before or after)
            if ((ev.endTicks || 0) < startWindow - ppq * 0.05) continue; // long gone
            if ((ev.startTicks || 0) > endWindow + ppq * 0.05) break;    // not yet
            // Perspective mapping for start/end
            const startDT = (ev.startTicks || 0) - nowT; // ticks until hit
            const endDT = (ev.endTicks || 0) - nowT;
            const uStart = clamp(1 - (startDT / lookaheadTicks), 0, 1);
            const uEnd = clamp(1 - (endDT / lookaheadTicks), 0, 1);
            const yStart = uToY(uStart);
            const yEnd = uToY(uEnd);
            const minH = 6;

            const topIsEnd = yEnd < yStart;
            const yTop = topIsEnd ? yEnd : yStart;
            const yBot = topIsEnd ? yStart : yEnd;

            const heightNow = Math.max(yBot - yTop, minH);

            // OPEN note? Draw a full-width translucent white band (no perspective).
            if (ev.open) {
              // trailing glow (use the note color)
              ctx.save();
              ctx.globalCompositeOperation = 'lighter';
              ctx.globalAlpha = 0.10;
              ctx.fillStyle = ev.color;
              ctx.fillRect(0, yTop - 4, width, heightNow + 8);
              ctx.restore();

              // main band in the note color
              ctx.save();
              ctx.globalAlpha = 0.28;
              ctx.fillStyle = ev.color;
              ctx.fillRect(0, yTop, width, heightNow);
              ctx.restore();

              // subtle edges
              ctx.strokeStyle = 'rgba(255,255,255,0.28)';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(0, yTop); ctx.lineTo(width, yTop);
              ctx.moveTo(0, yTop + heightNow); ctx.lineTo(width, yTop + heightNow);
              ctx.stroke();

              // Judgement for open notes: hit if *no keys* are pressed at the start edge
              if (!ev.judged) {
                const msPerTick = 60000 / (ppq * bpm);
                const errorMs = ((ev.startTicks || 0) - nowT) * msPerTick;
                if (Math.abs(errorMs) <= 80) {
                  const ok = (keyStateMask === 0);
                  ev.hit = ok || ev.hit;
                  ev.judged = true;
                  onHitJudgement && onHitJudgement(ev, ok, errorMs);
                } else if (errorMs < -150) {
                  ev.judged = true;
                  onHitJudgement && onHitJudgement(ev, false, errorMs);
                }
              }
              continue; // skip the lane-based drawing
            }

            const [cxTop, wTop] = laneGeom(
              ev.lane,
              topIsEnd ? Math.max(uEnd, 0.001) : uStart
            );
            const [cxBot, wBot] = laneGeom(
              ev.lane,
              topIsEnd ? uStart : Math.max(uEnd, 0.001)
            );
            const xSL = cxTop - wTop * 0.5;
            const xSR = cxTop + wTop * 0.5;
            const xEL = cxBot - wBot * 0.5;
            const xER = cxBot + wBot * 0.5;


            // 1) Tight, centered trail
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const trailSteps = 2;
            for (let t = trailSteps; t >= 1; t--) {
              const alpha = 0.05 * t;           // lower intensity
              const yShift = -t * 3;            // shorter smear
              ctx.save();
              ctx.translate(0, yShift);
              drawTopRoundedTrapezoid(
                xSL, xSR, yTop,
                xEL, xER, yTop + heightNow,
                8                                  // small top radius
              );
              ctx.fillStyle = ev.color;
              ctx.globalAlpha = alpha;
              ctx.fill();
              ctx.restore();
            }
            ctx.restore();

            const prevJoin = ctx.lineJoin, prevMiter = ctx.miterLimit;
            ctx.lineJoin = 'bevel';
            ctx.miterLimit = 2;

            drawTopRoundedTrapezoid(
              xSL, xSR, yTop,
              xEL, xER, yTop + heightNow,
              0                                  // top radius only
            );
            ctx.fillStyle = ev.hit ? 'rgba(68,224,166,1)' : ev.color;
            ctx.globalAlpha = 0.98;
            ctx.fill();

            // 3) Subtle edge & inner lift 
            ctx.lineWidth = 1.1;
            ctx.strokeStyle = 'rgba(2,6,23,0.55)';
            ctx.stroke();
            ctx.lineJoin = prevJoin; ctx.miterLimit = prevMiter;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 0.08;
            // inset a hair for a soft spec highlight
            drawTopRoundedTrapezoid(
              xSL + 1, xSR - 1, yTop + 0.5,
              xEL + 1, xER - 1, yTop + heightNow - 0.5,
              0
            );
            ctx.fillStyle = ev.color;
            ctx.fill();
            ctx.restore();


            // Judge near hit line only once
            if (!ev.judged) {
              // If start passes within +-80ms (convert ticks->ms at current BPM)
              const msPerTick = 60000 / (ppq * bpm);
              const errorMs = ((ev.startTicks || 0) - nowT) * msPerTick;

              if (Math.abs(errorMs) <= 80) {
                const laneBit = (ev.lane === 0 ? VALVE1 : (ev.lane === 1 ? VALVE2 : VALVE3));
                const ok = !!(keyStateMask & laneBit);
                ev.hit = ok || ev.hit; // keep any hit true
                ev.judged = true;
                onHitJudgement && onHitJudgement(ev, ok, errorMs);
              } else if (errorMs < -150) {
                // Missed decisively
                ev.judged = true;
                onHitJudgement && onHitJudgement(ev, false, errorMs);
              }
            }
          }
          ctx.shadowBlur = 0;
        }

        function drawTuner() {
          if (!micEnabledRef.current) return;
          // Show the tuner whenever we have a target note.
          const haveTarget = Number.isFinite(targetMidiRef.current);
          const nowSec = performance.now() / 1000;
          if (micNoteRef.current?.freq > 0) lastVoiceSecRef.current = nowSec;
          const voiceActive = (nowSec - lastVoiceSecRef.current) < 0.18; // still tracked for subtle styling if desired
          const shouldShow = haveTarget;

          // smooth alpha toward target
          const targetA = shouldShow ? 1 : 0;
          // quick in, gentle out
          const k = shouldShow ? 0.35 : 0.15; // lerp factor per frame
          tunerAlphaRef.current += (targetA - tunerAlphaRef.current) * k;
          if (tunerAlphaRef.current < 0.03) return; // effectively invisible → skip draw

          if (!haveTarget) return;
          const targetMidi = targetMidiRef.current;
          const targetFreq = midiToFreq(targetMidi);
          const hasMic = !!(micNoteRef.current && micNoteRef.current.freq > 0);
          const f = hasMic ? micNoteRef.current.freq : null;

          // error against *this* octave target
          const diff = hasMic ? (1200 * Math.log2(f / targetFreq)) : null; // cents (+: sharp/high, –: flat/low)
          const tol = tunerToleranceCents || 15;

          // If the player is an octave off but otherwise in tune, show a little “±8”
          const kOct = Math.round(Math.log2(f / targetFreq)); // nearest octave offset
          const diffOct = 1200 * Math.log2((f / targetFreq) / Math.pow(2, kOct || 0));
          const octaveOff = (kOct !== 0) && (Math.abs(diffOct) <= tol);

          const inTune = (diff !== null) && (Math.abs(diff) <= tol);
          const cx = Math.round(width / 2);
          const centerY = Math.round(height * tunerYRatio);  // middle of highway

          ctx.save();
          ctx.globalAlpha = tunerAlphaRef.current;
          ctx.translate(cx, centerY);

          // Helper to draw a filled chevron (triangle) pointing up/down
          const drawChevron = (x, y, size, up) => {
            ctx.beginPath();
            if (up) {
              ctx.moveTo(x - size, y + size * 0.9);
              ctx.lineTo(x,         y - size * 0.9);
              ctx.lineTo(x + size, y + size * 0.9);
            } else {
              ctx.moveTo(x - size, y - size * 0.9);
              ctx.lineTo(x,         y + size * 0.9);
              ctx.lineTo(x + size, y - size * 0.9);
            }
            ctx.closePath();
            ctx.fill();
          };

          if (!hasMic) {
             const r = (width < 420 ? 16 : 22);
             // dark fill behind ring for legibility on bright tiles
             ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2);
             ctx.fillStyle = 'rgba(2,6,23,0.55)'; ctx.fill();
             // outer dark stroke then inner light stroke (dual stroke)
             ctx.lineWidth = 4;
             ctx.strokeStyle = 'rgba(0,0,0,0.85)'; ctx.stroke();
             ctx.lineWidth = 2;
             ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.stroke();
            // tiny target label (e.g., "A#4")
            ctx.font = (width < 420 ? '11px' : '12px') + ' ui-sans-serif, system-ui';
            ctx.fillStyle = 'rgba(203,213,225,0.9)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            try {
              const name = midiToNoteName(targetMidi);
              ctx.fillText(name, 0, r + 4);
            } catch {}
            ctx.restore();
            return;
          }

          if (inTune) {
             // Green “you’re on it” ring — larger + clearer
             const r = (width < 420 ? 16 : 22);
             ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2);
             ctx.fillStyle = 'rgba(2,6,23,0.55)'; ctx.fill();
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(34,197,94,1)'; // emerald-500
            ctx.lineWidth = 4;
            ctx.stroke();
            // soft glow
            ctx.globalCompositeOperation = 'lighter';
            ctx.shadowColor = 'rgba(34,197,94,0.85)';
            ctx.shadowBlur = 14;
            ctx.beginPath();
            ctx.arc(0, 0, r + 7, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(34,197,94,0.55)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Optional tiny octave badge if “in tune” but ±1 octave
            if (octaveOff) {
              ctx.globalCompositeOperation = 'source-over';
              ctx.font = (width < 420 ? '10px' : '11px') + ' ui-sans-serif, system-ui';
              ctx.fillStyle = 'rgba(255,255,255,0.85)';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(kOct > 0 ? '+8' : '–8', r + 10, 0);
            }
            ctx.restore();
            return;
          }

          // Off target: single directional chevron; opacity/size scale with error magnitude
          const abs = Math.abs(diff);
          const wrong = clamp(abs / 100, 0, 1);         // 0..1 over ~100¢
          const size = (width < 420 ? 10 : 12) + 14 * wrong;
          const alpha = 0.35 + 0.65 * wrong;
          const goUp = diff < 0; // mic lower → raise pitch

           // Bigger, high-contrast ring as anchor (dark fill + dual stroke — fixes #1)
           const r = (width < 420 ? 16 : 22);
           ctx.globalAlpha = 0.9;
           ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2);
           ctx.fillStyle = 'rgba(2,6,23,0.55)'; ctx.fill();
           ctx.lineWidth = 4; ctx.strokeStyle = 'rgba(0,0,0,0.85)'; ctx.stroke();
           ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.85)'; ctx.stroke();

          ctx.globalAlpha = alpha;
          ctx.fillStyle = 'rgba(148,221,255,0.95)'; // lane glow hue
          drawChevron(0, 0, size, goUp);

          // If exactly in-tune but wrong octave, show tiny ±8
          if (octaveOff) {
            ctx.globalAlpha = 0.9;
            ctx.font = (width < 420 ? '10px' : '11px') + ' ui-sans-serif, system-ui';
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(kOct > 0 ? '+8' : '–8', (width < 420 ? 24 : 28), 0);
          }
          ctx.restore();
        }


        let view = { running: true };
        function loop() {
          if (!view.running) return;
          drawBackground();
          drawNotes();
          drawTuner();
          rafRef.current = requestAnimationFrame(loop);
        }
        view.running = true;
        loop();

        return () => {
          view.running = false;
          if (rafRef.current) cancelAnimationFrame(rafRef.current);
        };
      }, [laneEvents, keyStateMask, width, height, lookahead, running, frame, hitYRatio, vanishYRatio, bpm, ppq]);

      // Pointer handlers (touch/mouse)
      const onPointerDown = (e) => {
        const c = canvasRef.current; if (!c) return;
        c.setPointerCapture?.(e.pointerId);
        const rect = c.getBoundingClientRect();
        const x = e.clientX - rect.left, y = e.clientY - rect.top;
        const m = laneMaskAtPoint(x, y);
        activePointersRef.current.set(e.pointerId, m);
        recomputeTouchUnion();
      };
      const onPointerMove = (e) => {
        if (!activePointersRef.current.has(e.pointerId)) return;
        const c = canvasRef.current; if (!c) return;
        const rect = c.getBoundingClientRect();
        const x = e.clientX - rect.left, y = e.clientY - rect.top;
        const m = laneMaskAtPoint(x, y);
        activePointersRef.current.set(e.pointerId, m);
        recomputeTouchUnion();
      };
      const onPointerUpOrCancel = (e) => {
        if (activePointersRef.current.has(e.pointerId)) {
          activePointersRef.current.delete(e.pointerId);
          recomputeTouchUnion();
        }
      };

      return (
        <canvas
          ref={canvasRef}
          className="w-full h-full rounded-md bg-transparent touch-none"
          onPointerDown={onPointerDown} onPointerMove={onPointerMove}
          onPointerUp={onPointerUpOrCancel} onPointerCancel={onPointerUpOrCancel}
        />
      );
    }

    /******************************
     * Microphone Pitch (simple autocorrelation)
     ******************************/
    function useMicPitch(enabled) {
      const [note, setNote] = useState(null); // { midi, freq, cents }
      const analyserRef = useRef(null);
      const sourceRef = useRef(null);
      const rafRef = useRef(null);
      const audioCtxRef = useRef(null);
      const bufRef = useRef(null);

      useEffect(() => {
        async function start() {
          if (!enabled) return;
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          audioCtxRef.current = audioCtx;
          const analyser = audioCtx.createAnalyser();
          analyser.fftSize = 2048;
          analyserRef.current = analyser;
          const source = audioCtx.createMediaStreamSource(stream);
          source.connect(analyser);
          sourceRef.current = source;

          bufRef.current = new Float32Array(analyser.fftSize);

          const ac = () => {
            if (!analyserRef.current) return;
            const buf = bufRef.current;
            analyser.getFloatTimeDomainData(buf);
            const f = autoCorrelate(buf, audioCtx.sampleRate);
            if (f > 40 && f < 2000) {
              const midi = freqToMidi(f);
              const ref = 440 * Math.pow(2, (midi - 69) / 12);
              const cents = Math.floor(1200 * Math.log2(f / ref));
              setNote({ midi, freq: f, cents });
            } else {
              setNote(null);
            }
            rafRef.current = requestAnimationFrame(ac);
          };
          ac();
        }
        start().catch(() => { });
        return () => {
          if (rafRef.current) cancelAnimationFrame(rafRef.current);
          try {
            analyserRef.current?.disconnect();
            sourceRef.current?.disconnect();
            audioCtxRef.current?.close();
          } catch { }
          analyserRef.current = null;
          sourceRef.current = null;
          audioCtxRef.current = null;
          setNote(null);
        };
      }, [enabled]);

      return note;
    }

    function autoCorrelate(buf, sampleRate) {
      // A basic autocorrelation pitch estimator
      const SIZE = buf.length;
      let rms = 0;
      for (let i = 0; i < SIZE; i++) { const val = buf[i]; rms += val * val; }
      rms = Math.sqrt(rms / SIZE);
      if (rms < 0.01) return -1;

      let r1 = 0, r2 = SIZE - 1, thres = 0.2;
      for (let i = 0; i < SIZE / 2; i++) if (Math.abs(buf[i]) < thres) { r1 = i; break; }
      for (let i = 1; i < SIZE / 2; i++) if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }

      const buf2 = buf.slice(r1, r2);
      const newSize = buf2.length;
      const c = new Array(newSize).fill(0);
      for (let i = 0; i < newSize; i++) {
        for (let j = 0; j < newSize - i; j++) c[i] += buf2[j] * buf2[j + i];
      }
      let d = 0; while (c[d] > c[d + 1]) d++;
      let maxval = -1, maxpos = -1;
      for (let i = d; i < newSize; i++) {
        if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
      }
      if (maxpos <= 0) return -1;
      // Interpolate
      const T0 = maxpos;
      const x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1] || x2;
      const a = (x1 + x3 - 2 * x2) / 2;
      const b = (x3 - x1) / 2;
      const shift = a ? -b / (2 * a) : 0;
      const period = T0 + shift;
      const freq = sampleRate / period;
      return freq;
    }

    /******************************
     * Controls
     ******************************/
    const IconPlay = (props) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" {...props}>
        <path d="M8 5.14v13.72c0 .8.86 1.3 1.56.88l10.2-6.86a1 1 0 0 0 0-1.64L9.56 4.38A1 1 0 0 0 8 5.14Z"/>
      </svg>
    );
    const IconPause = (props) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" {...props}>
        <path d="M7 5h4v14H7zM13 5h4v14h-4z"/>
      </svg>
    );
    const IconStop = (props) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" {...props}>
        <path d="M6 6h12v12H6z"/>
      </svg>
    );
    const IconToStart = (props) => (
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" {...props}>
        <path d="M5 5h2v14H5zM21 6.5v11c0 .8-.86 1.3-1.56.88L9.24 13.5a1 1 0 0 1 0-1.64l10.2-4.88c.7-.42 1.56.08 1.56.88Z"/>
      </svg>
    );

    function Controls({
      isLoaded, running, onPlayPause, onStop, onGoStart,
      bpm, onBpm, onFile, trackNames, trackIndex, onTrackIndex,
      stats, micNote, micEnabled, waitMode, onWaitMode, transposeSemis, onTransposeSemis,
      isMobile, onOpenPicker
    }) {
      // Minimal when running (both desktop & mobile)
      if (running && isMobile) {
        return (
          <div className="hud w-full flex items-center justify-center">
            <div className="transport" role="group" aria-label="Transport">
              <button className="tbtn" onClick={onGoStart} disabled={!isLoaded} title="Back to start" aria-label="Back to start">
                <IconToStart />
              </button>
              <button className="tbtn play" onClick={onPlayPause} disabled={!isLoaded} title={running ? "Pause (Space)" : "Play (Space)"} aria-label={running ? "Pause" : "Play"}>
                {running ? <IconPause /> : <IconPlay />}
              </button>
              <button className="tbtn" onClick={onStop} disabled={!isLoaded} title="Stop" aria-label="Stop">
                <IconStop />
              </button>
            </div>
          </div>
        );
      }

      // Mobile-first grid when *not* running
      if (isMobile) {
        return (
          <div className="hud w-full">
            <div className="grid grid-cols-2 gap-3 w-full">
              {/* Transport – centered & big */}
              <div className="col-span-2 flex justify-center">
                <div className="transport" role="group" aria-label="Transport">
                  <button className="tbtn" onClick={onGoStart} disabled={!isLoaded} title="Back to start" aria-label="Back to start">
                    <IconToStart />
                  </button>
                  <button className="tbtn play" onClick={onPlayPause} disabled={!isLoaded} title={running ? "Pause (Space)" : "Play (Space)"} aria-label={running ? "Pause" : "Play"}>
                    {running ? <IconPause /> : <IconPlay />}
                  </button>
                  <button className="tbtn" onClick={onStop} disabled={!isLoaded} title="Stop" aria-label="Stop">
                    <IconStop />
                  </button>
                </div>
              </div>

              {/* Pick song – opens modal (also allows upload inside modal) */}
              <button
                type="button"
                className="pill cursor-pointer hover:brightness-110"
                onClick={onOpenPicker}
                title="Choose a preloaded song or upload your own"
              >
                Pick song
              </button>

              {/* Track select */}
              <label className="pill col-span-2 flex items-center justify-center gap-2 text-sm">
                <span className="text-slate-300">Track</span>
                <select
                  className="bg-slate-900/70 border border-slate-700/60 rounded px-2 py-1"
                  value={trackIndex ?? 0}
                  onChange={(e) => onTrackIndex(+e.target.value)}
                  disabled={!isLoaded}
                >
                  {(trackNames || []).map((t, i) => <option key={i} value={i}>{t || `Track ${i + 1}`}</option>)}
                </select>
              </label>

              {/* Wait & Transpose side-by-side */}
              <button
                type="button"
                onClick={() => onWaitMode(!waitMode)}
                className={
                  "pill text-xs flex items-center justify-center " +
                  (waitMode ? "border border-emerald-400 text-emerald-300 bg-emerald-500/10" : "border border-slate-600 text-slate-200")
                }
                title="Require holding each correct note before continuing"
              >
                {waitMode ? "Play-to-Advance: On" : "Play-to-Advance: Off"}
              </button>

              <label className="pill text-sm flex items-center justify-center gap-2">
                <span className="text-slate-300">Key</span>
                <select
                  className="bg-slate-900/70 border border-slate-700/60 rounded px-2 py-1"
                  value={transposeSemis}
                  onChange={(e) => onTransposeSemis(parseInt(e.target.value, 10))}
                  title="Shift mic (concert) to written pitch"
                >
                  <option value={0}>C (0)</option>
                  <option value={2}>B♭ (+2)</option>
                  <option value={7}>F (+7)</option>
                  <option value={9}>E♭ (+9)</option>
                </select>
              </label>

              {/* Tempo slider – full width */}
              <label className="pill col-span-2 flex items-center gap-2 text-sm">
                <span className="text-slate-300">Tempo</span>
                <input className="flex-1" type="range" min="40" max="200" step="1" value={bpm} onChange={(e) => onBpm(+e.target.value)} />
                <span className="w-10 text-right">{bpm}</span>
                <span className="text-slate-400 text-xs ml-1">BPM</span>
              </label>

              {/* Stats / Mic – centered fine print */}
              <div className="col-span-2 text-center space-y-1">
                <div className="text-xs text-slate-300">
                  Hit: <span className="font-semibold" style={{ color: 'var(--laneA)' }}>
                    <span className="inline-block w-[6ch] text-right tabular-nums font-mono">{stats.hitTime.toFixed(2)}</span>s
                  </span>
                  <span className="mx-3">
                    Miss: <span className="font-semibold text-rose-400">
                      <span className="inline-block w-[6ch] text-right tabular-nums font-mono">{stats.missTime.toFixed(2)}</span>s
                    </span>
                  </span>
                  Acc: <span className="font-semibold">
                    <span className="inline-block w-[4ch] text-right tabular-nums font-mono">
                      {(stats.hitTime + stats.missTime) > 0 ? Math.round(100 * stats.hitTime / (stats.hitTime + stats.missTime)) : 0}
                    </span>%
                  </span>
                </div>
                <div className="text-xs text-slate-400 font-mono tabular-nums">
                  {micEnabled
                    ? (micNote ? `Mic: ${midiToNoteName(micNote.midi)} ${micNote.cents >= 0 ? '+' : ''}${String(micNote.cents)}¢` : 'Mic: listening…')
                    : 'Mic: off'}
                </div>
              </div>
            </div>
          </div>
        );
      }

      // Desktop (unchanged layout)
      return (
        <div className="hud w-full">
          {/* LEFT CLUSTER */}
          <div className="flex-none mx-auto">
            <label className="pill flex items-center gap-2 text-sm">
              <span className="text-slate-300">Track</span>
              <select
                className="bg-slate-900/70 border border-slate-700/60 rounded px-2 py-1"
                value={trackIndex ?? 0}
                onChange={(e) => onTrackIndex(+e.target.value)}
                disabled={!isLoaded}
              >
                {(trackNames || []).map((t, i) => <option key={i} value={i}>{t || `Track ${i + 1}`}</option>)}
              </select>
              <button
                type="button"
                onClick={() => onWaitMode(!waitMode)}
                className={
                  "ml-1 px-3 py-1 rounded border text-xs " +
                  (waitMode ? "border-emerald-400 text-emerald-300 bg-emerald-500/10" : "border-slate-600 text-slate-200")
                }
                title="Require holding each correct note before continuing"
              >{waitMode ? "Play-to-Advance: On" : "Play-to-Advance: Off"}</button>
            </label>
          </div>

          {/* CENTER CLUSTER */}
          <div className="justify-self-center">
            <div className="transport" role="group" aria-label="Transport">
              <button className="tbtn" onClick={onGoStart} disabled={!isLoaded} title="Back to start" aria-label="Back to start">
                <IconToStart />
              </button>
              <button
                className="tbtn play"
                onClick={onPlayPause}
                disabled={!isLoaded}
                title={running ? "Pause (Space)" : "Play (Space)"}
                aria-label={running ? "Pause" : "Play"}
              >
                {running ? <IconPause /> : <IconPlay />}
              </button>
              <button className="tbtn" onClick={onStop} disabled={!isLoaded} title="Stop" aria-label="Stop"><IconStop /></button>
            </div>
          </div>

          {/* RIGHT CLUSTER */}
          <div className="flex items-center gap-2 justify-end flex-1 basis-0 min-w-[320px] flex-wrap">
            <label className="pill flex items-center gap-2 text-sm">
              <span className="text-slate-300">Tempo</span>
              <input className="w-40" type="range" min="40" max="200" step="1" value={bpm} onChange={(e) => onBpm(+e.target.value)} />
              <span className="w-10 text-right">{bpm}</span>
              <span className="text-slate-400 text-xs ml-1">BPM</span>
            </label>

            <label className="pill flex items-center gap-2 text-sm">
              <span className="text-slate-300">Transposition</span>
              <select
                className="bg-slate-900/70 border border-slate-700/60 rounded px-2 py-1"
                value={transposeSemis}
                onChange={(e) => onTransposeSemis(parseInt(e.target.value, 10))}
                title="Shift mic (concert) to written pitch"
              >
                <option value={0}>C (0)</option>
                <option value={2}>B♭ (+2)</option>
                <option value={7}>F (+7)</option>
                <option value={9}>E♭ (+9)</option>
              </select>
            </label>

            <button
              type="button"
              className="pill text-sm hover:brightness-110"
              onClick={onOpenPicker}
              title="Choose a preloaded song or upload your own"
            >Pick song</button>

            <div className="text-xs text-slate-300 ml-1">
              <span className="mr-3">
                Hit: <span className="font-semibold" style={{ color: 'var(--laneA)' }}>
                  <span className="inline-block w-[6ch] text-right tabular-nums font-mono">{stats.hitTime.toFixed(2)}</span>s
                </span>
              </span>
              <span className="mr-3">
                Miss: <span className="font-semibold text-rose-400">
                  <span className="inline-block w-[6ch] text-right tabular-nums font-mono">{stats.missTime.toFixed(2)}</span>s
                </span>
              </span>
              <span>
                Acc: <span className="font-semibold">
                  <span className="inline-block w-[4ch] text-right tabular-nums font-mono">
                    {(stats.hitTime + stats.missTime) > 0 ? Math.round(100 * stats.hitTime / (stats.hitTime + stats.missTime)) : 0}
                  </span>%
                </span>
              </span>
            </div>

            <div className="text-xs text-slate-400 font-mono tabular-nums">
              <span className="inline-block w-[18ch]">
                {micEnabled
                  ? (micNote ? `Mic: ${midiToNoteName(micNote.midi)} ${micNote.cents >= 0 ? '+' : ''}${String(micNote.cents)}¢` : 'Mic: listening…')
                  : 'Mic: off'}
              </span>
            </div>
          </div>
        </div>
      );
    }


    /******************************
     * Menu / Settings
     ******************************/
    function MenuPane({
      open, onClose,
      keyMap, setKeyMap,
      lookahead, setLookahead,
      micEnabled, setMicEnabled,
      expertMode, setExpertMode,
      transposeSemis, setTransposeSemis,
      showScore, setShowScore,
      showHighway, setShowHighway,
      showNoteNames, setShowNoteNames,
      showLastTake, setShowLastTake,
      overlayOpacity, setOverlayOpacity,
      onResetSettings = () => { },
    }) {
      const [capturing, setCapturing] = useState(null); // 'valve1' | ...

      useEffect(() => {
        function onKey(e) {
          if (!capturing) return;
          e.preventDefault();
          const k = e.key.toLowerCase();
          const updated = { ...keyMap };
          const v = capturing === 'valve1' ? VALVE1 : capturing === 'valve2' ? VALVE2 : VALVE3;
          // Remove previous mapping of this valve
          for (const kk of Object.keys(updated)) {
            if (updated[kk] === v) delete updated[kk];
          }
          updated[k] = v;
          setKeyMap(updated);
          setCapturing(null);
        }
        if (capturing) window.addEventListener('keydown', onKey, { once: true });
        return () => window.removeEventListener('keydown', onKey);
      }, [capturing, keyMap, setKeyMap]);

      if (!open) return null;
      return (
        <div className="fixed inset-0 z-50">
          <div className="absolute inset-0 bg-black/60" onClick={onClose}></div>
          <div className="absolute left-0 top-0 h-full w-[320px] bg-slate-800 shadow-xl p-4 overflow-y-auto">
            <div className="flex items-center justify-between pb-2 mb-2 border-b border-slate-700">
              <h2 className="text-lg font-semibold">Settings</h2>
              <button onClick={onClose} className="text-slate-300 hover:text-white">✕</button>
            </div>

            <section className="mb-6">
              <h3 className="font-semibold mb-2">Input mapping</h3>
              <p className="text-xs text-slate-400 mb-2">Press a button to re-map; currently:</p>
              <div className="sm:block hidden">
                <KeyMapRow
                  label="Valve 1"
                  capture={() => setCapturing('valve1')}
                  active={capturing === 'valve1'}
                  currentKey={displayKeyForValve(keyMap, VALVE1)}
                />
                <KeyMapRow
                  label="Valve 2"
                  capture={() => setCapturing('valve2')}
                  active={capturing === 'valve2'}
                  currentKey={displayKeyForValve(keyMap, VALVE2)}
                />
                <KeyMapRow
                  label="Valve 3"
                  capture={() => setCapturing('valve3')}
                  active={capturing === 'valve3'}
                  currentKey={displayKeyForValve(keyMap, VALVE3)}
                />
                <div className="mt-3">
                  <button className="text-xs underline text-slate-300" onClick={() => setKeyMap({ ...defaultKeyMap })}>Reset to A/S/D</button>
                </div>
              </div>
            </section>

            <section className="mb-6">
              <h3 className="font-semibold mb-2">Display</h3>
              <label className="flex items-center gap-2 text-sm mb-2">
                <input
                  type="checkbox"
                  checked={showScore}
                  onChange={(e) => setShowScore(e.target.checked)}
                />
                <span>Show score (staff notation)</span>
              </label>
              <label className="flex items-center gap-2 text-sm">
                <input
                  type="checkbox"
                  checked={showHighway}
                  onChange={(e) => setShowHighway(e.target.checked)}
                />
                <span>Show highway (valve lanes)</span>
              </label>
              <label className="flex items-center gap-2 text-sm">
                <input
                  type="checkbox"
                  onChange={(e) => setShowNoteNames(e.target.checked)}
                  id="show-note-names-toggle"
                  checked={showNoteNames}
                />
                <span>Show note names on score</span>
              </label>

              <div className="mt-3 pt-3 border-t border-slate-700/60">
                <h4 className="font-semibold mb-2">Last take overlay</h4>
                <label className="flex items-center gap-2 text-sm mb-2">
                  <input
                    type="checkbox"
                    checked={showLastTake}
                    onChange={(e) => setShowLastTake(e.target.checked)}
                  />
                  <span>Show last take overlay</span>
                </label>
                <label className="flex items-center gap-2 text-sm">
                  <span className="text-slate-300">Opacity</span>
                  <input className="flex-1" type="range" min="0" max="1" step="0.05" value={overlayOpacity}
                         onChange={(e) => setOverlayOpacity(parseFloat(e.target.value))} />
                  <span className="w-10 text-right">{Math.round((overlayOpacity ?? 1)*100)}</span>
                  <span className="text-slate-400 text-xs ml-1">%</span>
                </label>
              </div>

            </section>

            <section className="mb-6">
              <h3 className="font-semibold mb-2">Visual difficulty</h3>
              <label className="text-sm text-slate-300">Note speed (seconds top → hit)</label>
              <input
                className="w-full mt-2"
                type="range" min="2" max="6" step="0.1"
                value={lookahead}
                onChange={(e) => setLookahead(+e.target.value)}
              />
              <div className="text-xs text-slate-400 mt-1">{lookahead.toFixed(1)} s</div>
            </section>

            <section className="mb-6">
              <h3 className="font-semibold mb-2">Microphone</h3>
              <label className="flex items-center gap-2 text-sm">
                <input type="checkbox" checked={micEnabled} onChange={(e) => setMicEnabled(e.target.checked)} />
                <span>Enable microphone pitch feedback</span>
              </label>
              <label className="flex items-center gap-2 text-sm mt-2">
                <input
                  type="checkbox"
                  checked={expertMode}
                  onChange={(e) => setExpertMode(e.target.checked)}
                />
                <span>Expert mode (no tolerance)</span>
              </label>
              <p className="text-xs text-slate-400 mt-2">Simple autocorrelation detector; use a quiet room for best results.</p>
              <div className="mt-3">
                <label className="text-sm text-slate-300 block mb-1">Instrument transposition (semitones)</label>
                <select
                  className="bg-slate-900/70 border border-slate-700/60 rounded px-2 py-1"
                  value={transposeSemis}
                  onChange={(e) => setTransposeSemis(parseInt(e.target.value, 10))}
                >
                  <option value={0}>C (0)</option>
                  <option value={2}>B♭ (+2)</option>
                  <option value={7}>F (+7)</option>
                  <option value={9}>E♭ (+9)</option>
                </select>
                <p className="text-xs text-slate-400 mt-1">
                  Converts mic’s concert pitch to written pitch for comparison/overlay.
                </p>
              </div>

            </section>

            <footer className="text-xs text-slate-400">
              <div className="mt-4 pt-3 border-t border-slate-700 space-y-2">
                <button
                  type="button"
                  onClick={onResetSettings}
                  className="block text-rose-300 hover:text-rose-200"
                >
                  Reset saved settings
                </button>
                <a
                  href="https://findonsoftware.com/"
                  target="_blank"
                  rel="noopener noreferrer"
                  className="block text-slate-300 hover:text-white"
                >
                  Built by Findon Software
                </a>
                <a
                  href="https://github.com/hutchpd/Trumpet/issues"
                  target="_blank"
                  rel="noopener noreferrer"
                  className="block text-slate-300 hover:text-white"
                >
                  Feedback &amp; issues on GitHub
                </a>
              </div>
            </footer>

          </div>
        </div>
      );
    }

    function KeyMapRow({ label, capture, active, currentKey }) {
      return (
        <div className="flex items-center justify-between gap-2 py-1">
          <div>{label}</div>
          <button
            onClick={capture}
            className={'px-3 py-1 rounded border ' + (active ? 'border-emerald-400 text-emerald-300' : 'border-slate-600 text-slate-200')}
            title="Click then press a key"
          >
            {active ? 'Press a key…' : (currentKey || '—')}
          </button>
        </div>
      );
    }

    function displayKeyForValve(keyMap, valveBit) {
      for (const [k, v] of Object.entries(keyMap)) if (v === valveBit) return k.toUpperCase();
      return '';
    }

    /******************************
     * Song Catalog (easy to extend)
     ******************************/
    const SONG_CATALOG = {
      songs: [
        /*        { id: 'happy-birthday', title: 'Happy Birthday', url: './songs/happy_birthday.mid' },
                { id: 'bella-ciao', title: 'Bella Ciao', url: './songs/bella_ciao.mid' },
                { id: 'wellerman', title: 'Wellerman (Sea Shanty)', url: './songs/wellerman.mid' },
                { id: 'largo-dvorak', title: 'Largo (From “New World” Symphony)', url: './songs/largo_new_world.mid' },*/
        { id: 'ode-to-joy', title: 'Ode to Joy', url: './songs/ode_to_joy.mid' },
        { id: 'oompa-loompa', title: 'Oompa Loompa', url: './songs/oompa_loompa.mid' }
      ],
      scales: [
        { id: 'c-major-1oct', title: 'C Major – 1 octave', url: './scales/C_major_1oct.mid' },
        { id: 'bb-major-1oct', title: 'B♭ Major – 1 octave', url: './scales/Bb_major_1oct.mid' },
        /*
        { id: 'g-major-1oct', title: 'G Major – 1 octave', url: './scales/G_major_1oct.mid' },
        { id: 'f-major-1oct', title: 'F Major – 1 octave', url: './scales/F_major_1oct.mid' } */
      ]
    };

    /******************************
     * Song Picker Modal
     ******************************/
    function SongPickerModal({ open, onClose, onPickUrl, onUploadFile }) {
      if (!open) return null;
      const Section = ({ label, items }) => (
        <div className="mb-6">
          <h3 className="text-sm font-semibold text-slate-200 mb-2">{label}</h3>
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
            {items.map(item => (
              <button
                key={item.id}
                onClick={() => { onPickUrl(item.url, item.title); }}
                className="text-left px-3 py-2 rounded-lg border border-slate-700/60 bg-slate-800/70 hover:bg-slate-700/60"
              >
                <div className="font-medium">{item.title}</div>
                <div className="text-xs text-slate-400 break-all">{item.url}</div>
              </button>
            ))}
          </div>
        </div>
      );

      return (
        <div className="fixed inset-0 z-50">
          <div className="absolute inset-0 bg-black/70" onClick={onClose} />
          <div className="absolute inset-0 sm:inset-auto sm:top-1/2 sm:left-1/2 sm:-translate-x-1/2 sm:-translate-y-1/2
                          sm:max-w-[720px] sm:w-[92vw] sm:max-h-[85vh] sm:rounded-xl
                          bg-slate-900/95 border border-slate-700/60 shadow-xl
                          flex flex-col h-full sm:h-auto">
            <div className="p-4 border-b border-slate-700/60 flex items-center">
              <h2 className="text-lg font-semibold">Pick a song</h2>
              <button className="ml-auto px-3 py-1 rounded hover:bg-slate-700" onClick={onClose} aria-label="Close">✕</button>
            </div>
            <div className="p-4 overflow-y-auto">
              <Section label="Songs" items={SONG_CATALOG.songs} />
              <Section label="Scales" items={SONG_CATALOG.scales} />
              <div className="mt-8">
                <h3 className="text-sm font-semibold text-slate-200 mb-2">Or upload your own</h3>
                <label className="inline-block pill cursor-pointer hover:brightness-110">
                  <input className="hidden" type="file" accept=".mid,.midi,audio/midi" onChange={(e) => onUploadFile(e.target.files?.[0] || null)} />
                  <span>Upload MIDI…</span>
                </label>
              </div>
            </div>
          </div>
        </div>
      );
    }



    /******************************
     * App
     ******************************/
    function App() {
      const initialSettings = useRef(loadSettings()).current;
      const [menuOpen, setMenuOpen] = useState(false);
      const [keyMap, setKeyMap] = useState({ ...initialSettings.keyMap });
      const [keyMask, setKeyMask] = useState(0);
      const [touchMask, setTouchMask] = useState(0);
      const [pressedMask, setPressedMask] = useState(0);

      const [lookahead, setLookahead] = useState(initialSettings.lookahead);
      const [micEnabled, setMicEnabled] = useState(initialSettings.micEnabled);
      const [expertMode, setExpertMode] = useState(initialSettings.expertMode);
      const [waitMode, setWaitMode] = useState(initialSettings.waitMode);
      const [transposeSemis, setTransposeSemis] = useState(initialSettings.transposeSemis);

      const [showScore, setShowScore] = useState(
        typeof initialSettings.showScore === 'boolean' ? initialSettings.showScore : true
      );
      const [showHighwaySetting, setShowHighway] = useState(
        typeof initialSettings.showHighway === 'boolean' ? initialSettings.showHighway : true
      );

      const [showNoteNames, setShowNoteNames] = useState(
        typeof initialSettings.showNoteNames === 'boolean' ? initialSettings.showNoteNames : false
      );

      const [showLastTake, setShowLastTake] = useState(!!initialSettings.showLastTake);
      const [overlayOpacity, setOverlayOpacity] = useState(initialSettings.overlayOpacity ?? 0.9);

      const [isFullscreen, setIsFullscreen] = useState(!!document.fullscreenElement);
      const [isMobile, setIsMobile] = useState(window.matchMedia('(max-width: 640px)').matches);
      const [pickerOpen, setPickerOpen] = useState(false);
      useEffect(() => {
        const onFs = () => setIsFullscreen(!!document.fullscreenElement);
        document.addEventListener('fullscreenchange', onFs);
        const mq = window.matchMedia('(max-width: 640px)');
        const onMM = (e) => setIsMobile(e.matches);
        mq.addEventListener?.('change', onMM) || mq.addListener(onMM);
        return () => {
          document.removeEventListener('fullscreenchange', onFs);
          mq.removeEventListener?.('change', onMM) || mq.removeListener(onMM);
        };
      }, []);

      const [midiMeta, setMidiMeta] = useState({ title: 'No song loaded', tracks: [] });
      const [trackIndex, setTrackIndex] = useState(0);
      const [notes, setNotes] = useState([]); // selected track notes
      const [laneEvents, setLaneEvents] = useState([]);

      const [bpm, setBpm] = useState(120);
      const [timeSig, setTimeSig] = useState([4, 4]);

      // -------- RunLog for last take --------
      // live accumulation during a run (key/mic timing)
      const runLogRef = useRef([]);        // Array<RunLogItem>
      const [lastTake, setLastTake] = useState(null); // frozen copy to render
      // quick index for startTicks -> note index
      const noteIndexByStartRef = useRef(new Map());
      // helper to reset logs
      const resetRunLog = useCallback(() => { runLogRef.current = []; setLastTake(null); }, []);
      // utility to mark/merge a note judgement (once per expected note)
      const upsertRunLog = useCallback((noteIdx, patch) => {
        if (noteIdx == null || noteIdx < 0 || noteIdx >= notes.length) return;
        const n = notes[noteIdx];
        let rec = runLogRef.current.find(r => r.noteIndex === noteIdx);
        if (!rec) {
          rec = {
            noteIndex: noteIdx,
            startTicks: n.ticks || 0,
            endTicks: (n.ticks || 0) + (n.durationTicks || 0),
            expectedPitch: n.midi ?? noteNameToMidi(n.name),
            result: 'miss',
            source: 'keys',
            timingErrorMs: null
          };
          runLogRef.current.push(rec);
        }
        Object.assign(rec, patch || {});
      }, [notes]);

      const [running, setRunning] = useState(false);
      const [canvasSize, setCanvasSize] = useState({ w: 0, h: 0 });
      const highwayMeasureRef = useRef(null);
      const highwayPulseRef = useRef(null);

      const scoreMeasureRef = useRef(null);
      const [scoreSize, setScoreSize] = useState({ w: 0, h: 0 });

      const [stats, setStats] = useState({ hitTime: 0, missTime: 0 });
      const statsRef = useRef({ hitTime: 0, missTime: 0 });
      const pressedMaskRef = useRef(0);

      const showHighwayAuto = !isMobile || (notes.length > 0 && (running || waitMode));
      const showHighway = showHighwaySetting && showHighwayAuto;

      // Persist whenever any user-facing setting changes
      useEffect(() => {
        persistSettings({
          keyMap, lookahead, micEnabled, expertMode, waitMode, transposeSemis,
          showScore, showHighway: showHighwaySetting,
          showNoteNames, showLastTake, overlayOpacity
        });
      }, [keyMap, lookahead, micEnabled, expertMode, waitMode, transposeSemis, showScore, showHighwaySetting, showNoteNames, showLastTake, overlayOpacity]);

      // Combine keyboard + touch into effective pressed mask
      useEffect(() => {
        setPressedMask(keyMask | touchMask);
      }, [keyMask, touchMask]);

      // Optional nicety: if user previously enabled mic, only auto-enable
      // when permission is already granted (prevents surprise prompt on load)
      useEffect(() => {
        if (!initialSettings.micEnabled) return;
        if (!navigator.permissions?.query) return;
        try {
          navigator.permissions.query({ name: 'microphone' }).then(p => {
            if (p.state === 'granted') setMicEnabled(true);
          }).catch(() => { });
        } catch { }
      }, []);

      // One-click reset (also clears storage)
      const resetSettings = useCallback(() => {
        try { localStorage.removeItem(SETTINGS_KEY); } catch { }
        setKeyMap({ ...defaultKeyMap });
        setLookahead(DEFAULT_SETTINGS.lookahead);
        setMicEnabled(DEFAULT_SETTINGS.micEnabled);
        setExpertMode(DEFAULT_SETTINGS.expertMode);
        setWaitMode(DEFAULT_SETTINGS.waitMode);
        setTransposeSemis(DEFAULT_SETTINGS.transposeSemis);
        setShowScore(DEFAULT_SETTINGS.showScore);
        setShowHighway(DEFAULT_SETTINGS.showHighway);
      }, []);

      useEffect(() => { pressedMaskRef.current = pressedMask; }, [pressedMask]);
      const micNoteRaw = useMicPitch(micEnabled);
      // Convert mic (concert) -> written pitch for comparisons/overlay/display
      const micNote = useMemo(() => {
        if (!micNoteRaw) return null;
        const semis = transposeSemis || 0;
        return {
          midi: micNoteRaw.midi + semis,
          // shift freq so cents comparisons remain valid against written target
          freq: micNoteRaw.freq * Math.pow(2, semis / 12),
          // keep cents relative to shifted ref: recompute against transposed midi
          cents: (() => {
            const ref = midiToFreq(micNoteRaw.midi + semis);
            return Math.floor(1200 * Math.log2((micNoteRaw.freq * Math.pow(2, semis / 12)) / ref));
          })()
        };
      }, [micNoteRaw, transposeSemis]);
      useEffect(() => { window.__lastMicNoteWritten = micNote || null; }, [micNote]);

      const {
        scheduleLeadPart,
        scheduleBackingPart,
        clearLeadPart,
        clearBackingPart,
        initAudio,
        readyRef,
        stopAll,
        setBackingMuted
      } = useToneSetup();

      const clearPart = React.useCallback(() => {
        try { clearLeadPart(); } catch {}
        try { clearBackingPart(); } catch {}
        try { Tone.Transport.cancel(); } catch {}
      }, [clearLeadPart, clearBackingPart]);


      // Stable sizing via ResizeObserver (prevents layout creep)
      useEffect(() => {
        const el = highwayMeasureRef.current;
        if (!el) return;
        const ro = new ResizeObserver(entries => {
          const r = entries[0].contentRect;
          setCanvasSize({ w: Math.round(r.width), h: Math.round(r.height) });
        });
        // Seed and observe
        const r0 = el.getBoundingClientRect();
        setCanvasSize({ w: Math.round(r0.width), h: Math.round(r0.height) });
        ro.observe(el);
        return () => ro.disconnect();
      }, [showHighway]);

      // Resize observer for the Score area when it's the only view (fill height)
      useEffect(() => {
        const el = scoreMeasureRef.current;
        if (!el) return;
        const ro = new ResizeObserver(entries => {
          const r = entries[0].contentRect;
          setScoreSize({ w: Math.round(r.width), h: Math.round(r.height) });
        });
        // seed and observe
        const r0 = el.getBoundingClientRect?.();
        if (r0?.width && r0?.height) {
          setScoreSize({ w: Math.round(r0.width), h: Math.round(r0.height) });
        }
        ro.observe(el);
        return () => ro.disconnect();
      }, []);


      function fixUtf8Mojibake(s) {
        try {
          // Heuristic: only attempt if it looks mojibaked
          if (!/[ÃÂâ]/.test(s)) return s;
          const bytes = new Uint8Array(Array.from(s, ch => ch.charCodeAt(0) & 0xFF));
          const rec = new TextDecoder('utf-8').decode(bytes);
          return rec;
        } catch { return s; }
      }


      // Shared MIDI loader (from ArrayBuffer), used by both URL & File
      const parseAndLoadMidi = async (arrayBuffer, sourceTitle = 'Untitled') => {
        const MidiClass = window.Midi || (window['tonejsMidi'] && window['tonejsMidi'].Midi) || window['TonejsMidi']?.Midi;
        if (!MidiClass) {
          alert('Failed to load @tonejs/midi. Please check your connection.');
          return;
        }
        const midi = new MidiClass(arrayBuffer);
        const title = fixUtf8Mojibake(midi.header.name || '') || sourceTitle || 'Untitled';
        const tempos = midi.header.tempos?.length ? midi.header.tempos : [{ bpm: 120, ticks: 0 }];
        const bpm0 = tempos[0].bpm || 120;
        const ts = midi.header.timeSignatures?.length ? midi.header.timeSignatures[0] : { timeSignature: [4, 4] };
        const tsArr = ts.timeSignature || [4, 4];

        const playableTracks = midi.tracks
          .map((t, i) => ({
            name: fixUtf8Mojibake(t.name || t.instrument?.name || `Track ${i + 1}`),
            srcIndex: i,
            notes: (t.notes || []).map(n => ({
              name: n.name, midi: n.midi, time: n.time, duration: n.duration,
              ticks: n.ticks, durationTicks: n.durationTicks, velocity: n.velocity
            }))
          }))
          .filter(t => (t.notes?.length || 0) > 0);

        setMidiMeta({ title, ppq: midi.header.ppq || 480, tracks: playableTracks });
        setTrackIndex(0);
        setBpm(Math.round(bpm0));
        setTimeSig([tsArr[0] || 4, tsArr[1] || 4]);

        const selectedNotes = playableTracks[0]?.notes?.map(n => ({ ...n })) || [];
        const t0 = selectedNotes.length ? selectedNotes[0].time : 0;
        const t0Ticks = selectedNotes.length ? (selectedNotes[0].ticks || 0) : 0;
        selectedNotes.forEach(n => { n.time -= t0; n.ticks = (n.ticks || 0) - t0Ticks; });
        setNotes(selectedNotes);

        // Build backing = all other tracks, aligned to selected's start, clamp to >= 0
        // Build note index map for overlay placement
        noteIndexByStartRef.current = new Map();
        selectedNotes.forEach((n, i) => {
          noteIndexByStartRef.current.set((n.ticks || 0), i);
        });
        // clear prior logs/overlay on new load
        resetRunLog();
        setLastTake(null);

        const backingRaw = playableTracks.slice(1).flatMap(t => t.notes || []);
        const backingNotes = backingRaw.map(n => ({
          ...n,
          time: Math.max(0, n.time - t0),
          ticks: Math.max(0, (n.ticks || 0) - t0Ticks)
        }));

        Tone.Transport.cancel();
        Tone.Transport.bpm.value = bpm0;
        Tone.Transport.position = 0;

        const transportPPQ = Tone.Transport.PPQ || 192;
        const midiPPQ = midi.header.ppq || 480;
        const scaleToTransport = transportPPQ / midiPPQ;
        scheduleLeadPart(selectedNotes, scaleToTransport);
        scheduleBackingPart(backingNotes, scaleToTransport);

        

        const events = buildLaneEvents(selectedNotes, bpm0, noteNameToMask, lookahead);
        setLaneEvents(events);

        setRunning(false);
        setStats({ hitTime: 0, missTime: 0 });
        statsRef.current = { hitTime: 0, missTime: 0 };
        resetRunLog();
      };

      // Load MIDI from a relative URL
      const onPickUrl = async (url, displayTitle) => {
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const buf = await res.arrayBuffer();
          await parseAndLoadMidi(buf, displayTitle || url.split('/').pop());
          setPickerOpen(false);
        } catch (err) {
          console.error(err);
          alert('Could not load that song. Check the URL/file exists on the server.');
        }
      };



      // Load MIDI from File
      const onFile = async (file) => {
        if (!file) return;
        const arr = await file.arrayBuffer();
        await parseAndLoadMidi(arr, file.name);
        setPickerOpen(false);
      };

      // When trackIndex changes
      useEffect(() => {
        if (!midiMeta.tracks.length) return;
        const t = midiMeta.tracks[trackIndex] || midiMeta.tracks[0];
        const n = (t.notes || []).map(x => ({ ...x }));
        if (n.length) {
          const t0 = n[0].time;
          const t0Ticks = n[0].ticks || 0;
          n.forEach(m => { m.time -= t0; m.ticks = (m.ticks || 0) - t0Ticks; });
        }
        setNotes(n);
        Tone.Transport.cancel();
        Tone.Transport.position = 0;
        // refresh index map + clear overlay/logs
        noteIndexByStartRef.current = new Map();
        n.forEach((m, i) => {
          noteIndexByStartRef.current.set((m.ticks || 0), i);
        });
        resetRunLog();
        setLastTake(null);
        const transportPPQ = Tone.Transport.PPQ || 192;
        const midiPPQ = midiMeta.ppq || 480;
        const scaleToTransport = transportPPQ / midiPPQ;
        // build backing = all other tracks, aligned to selected
        const backingRaw = midiMeta.tracks
          .filter((_, i) => i !== (trackIndex || 0))
          .flatMap(tr => tr.notes || []);
        const t0Ticks = n.length ? (n[0].ticks || 0) : 0;
        const t0Time = n.length ? n[0].time : 0;
        const backingNotes = backingRaw.map(b => ({
          ...b,
          time: Math.max(0, b.time - t0Time),
          ticks: Math.max(0, (b.ticks || 0) - t0Ticks)
        }));
        if (!waitMode) {
          scheduleLeadPart(n, scaleToTransport);
          scheduleBackingPart(backingNotes, scaleToTransport);
        } else {
          clearLeadPart();
          clearBackingPart();
          try { Tone.Transport.stop(); } catch { }
        }
        const events = buildLaneEvents(n, bpm, noteNameToMask, lookahead);
        setLaneEvents(events);
        setStats({ hitTime: 0, missTime: 0 });
        statsRef.current = { hitTime: 0, missTime: 0 };
        setRunning(false);
      }, [trackIndex, waitMode]);

      // Update BPM
      useEffect(() => {
        Tone.Transport.bpm.value = bpm;
      }, [bpm]);

      // Visual-only judgement (keeps lane glow etc.);
      const onHitJudgement = useCallback((ev, ok, errorMs) => {
        pulseAmpRef.current = Math.min(1, pulseAmpRef.current + 0.6);
        // Map event.startTicks -> note index and record a single per-note judgement
        const idx = noteIndexByStartRef.current.get(ev.startTicks || 0);
        if (idx != null) {
          const micOk = (() => {
            if (!micEnabled) return false;
            const expected = notes[idx];
            const expMidi = expected?.midi ?? noteNameToMidi(expected?.name || '');
            if (!Number.isFinite(expMidi)) return false;
            // same logic as mic overlay: exact midi or within ~35¢ (when not expert)
            if (window.__lastMicNoteWritten?.midi === expMidi) return true;
            if (!expertMode && window.__lastMicNoteWritten?.freq) {
              const c = centsDiff(window.__lastMicNoteWritten.freq, midiToFreq(expMidi));
              return Math.abs(c) <= 35;
            }
            return false;
          })();
          upsertRunLog(idx, {
            result: ok ? 'hit' : 'miss',
            source: (ok && micOk) ? 'both' : (ok ? 'keys' : (micOk ? 'mic' : 'keys')),
            timingErrorMs: (errorMs != null ? Math.round(errorMs) : null)
          });
        }
      }, [micEnabled, expertMode, notes, upsertRunLog]);

      // Play / Pause
      const togglePlay = async () => {
        await initAudio();
        if (!notes.length) return;
        if (waitMode) {
          if (!running) {
            setLastTake(null);
            resetRunLog();
            try { Tone.Transport.stop(); } catch { }
            clearPart();              // ensure nothing is scheduled
            setRunning(true);         // drive our own gate loop/UI
            // Optional: arm the first playable note right away
            armGateForIndex(0);
          } else {
            setRunning(false);
            gateRef.current = { active: false, noteIndex: -1 };
            try { Tone.Transport.stop(); } catch { }
            clearPart();
          }
          return;
        }
        // Normal mode: Transport drives playback
        if (Tone.Transport.state !== 'started') {
          setLastTake(null);
          resetRunLog();
          Tone.Transport.start('+0.05');
          setRunning(true);
        } else {
          Tone.Transport.pause();
          setRunning(false);
        }
      };

      // Jump to beginning (keep playing if already running in normal mode)
      const goToStart = useCallback(() => {
        const midiPPQ = midiMeta.ppq || 480;
        const transportPPQ = Tone.Transport.PPQ || 192;
        const toTransport = transportPPQ / midiPPQ;
        try {
          setLastTake(null);
          // In normal mode, if playing, jump while staying started; otherwise pause at start
          if (!waitMode && running && Tone.Transport.state === 'started') {
            Tone.Transport.ticks = 0;
          } else {
            Tone.Transport.pause();
            Tone.Transport.ticks = 0;
          }
        } catch { }
        setTransportTicks(0);
        setLastTake(null);
        resetRunLog();
        // In hold-to-advance mode, (re)arm the first playable note for gating if running
        if (waitMode && running) {
          gateRef.current = { active: false, noteIndex: -1 };
          armGateForIndex(0);
        }
      }, [midiMeta.ppq, waitMode, running, armGateForIndex]);

      // Stop: pause and return to beginning
      const stopTransport = useCallback(() => {
        try { Tone.Transport.stop(); } catch { }
        try { stopAll(); } catch { }
        setRunning(false);
        setTransportTicks(0);
        // Clear any gating state
        gateRef.current = { active: false, noteIndex: -1, requiredTicks: 0, holdTicks: 0, mask: 0, startTicks: 0, endTicks: 0, expectedMidi: null, lastWallSec: 0 };
      }, [stopAll]);



      // End-of-track detection (tick-based, tempo-invariant)
      useEffect(() => {
        if (!notes.length) return;
        let raf = null;
        // compute last MIDI tick in the current notes array
        const lastMidiTick =
          Math.max(0, ...notes.map(n => (n.ticks || 0) + (n.durationTicks || 0)));
        const check = () => {
          // convert Transport ticks -> MIDI ticks for comparison
          const midiPPQ = midiMeta.ppq || 480;
          const transportPPQ = Tone.Transport.PPQ || 192;
          const toMidi = midiPPQ / transportPPQ;
          const nowMidi = (Tone.Transport.ticks || 0) * toMidi;
          // small guard: allow a couple of ticks of slack
          if (nowMidi >= lastMidiTick - 1) {
            setRunning(false);
            Tone.Transport.stop();
            const totalT = stats.hitTime + stats.missTime;
            const acc = totalT ? Math.round(100 * stats.hitTime / totalT) : 0;
            console.log(`Session complete. Accuracy: ${acc}%`);
            // Build/finish RunLog for all expected notes and freeze it for overlay.
            // Ensure every note has an entry; infer 'miss' where none recorded (late misses respected).
            const msPerTick = 60000 / ((midiMeta.ppq || 480) * bpm);
            const finished = notes.map((n, i) => {
              let rec = runLogRef.current.find(r => r.noteIndex === i);
              if (!rec) {
                rec = {
                  noteIndex: i,
                  startTicks: n.ticks || 0,
                  endTicks: (n.ticks || 0) + (n.durationTicks || 0),
                  expectedPitch: n.midi ?? noteNameToMidi(n.name),
                  result: 'miss',
                  source: micEnabled ? 'mic' : 'keys',
                  timingErrorMs: null
                };
              }
              // Determine measure/index for placement using ScoreDisplay ordering
              const [num, den] = timeSig || [4,4];
              const beatsPerMeasure = num;
              const beats = ((n.ticks || 0) / (midiMeta.ppq || 480)) * (4 / den);
              const measure = Math.floor(beats / beatsPerMeasure);
              // index of this note inside its measure per orderByMeasureRef
              let idxInMeasure = 0;
              try {
                const ord = overlayApiRef.current?.orderByMeasureRef?.current?.[measure] || [];
                idxInMeasure = Math.max(0, ord.findIndex(o => (o.startTicks || 0) === (n.ticks || 0)));
              } catch {}
              rec.__loc = { measure, idxInMeasure, ticks: n.ticks || 0 };
              return rec;
            });
            // Freeze once per stop event
            setLastTake(finished);
            // Keep the live buffer for potential inspection, but we won't mutate it further.

          } else {
            raf = requestAnimationFrame(check);
          }
        };
        if (running) raf = requestAnimationFrame(check);
        return () => { if (raf) cancelAnimationFrame(raf); };
      }, [running, notes, midiMeta.ppq, stats]);


      // Current Transport seconds -> pass to score / highway AND do time-based scoring
      const [transportTicks, setTransportTicks] = useState(0); // stored as MIDI ticks for UI
      const handleSeekTicks = useCallback((midiTicks) => {
        const midiPPQ = midiMeta.ppq || 480;
        const transportPPQ = Tone.Transport.PPQ || 192;
        const toTransport = transportPPQ / midiPPQ;
        const safeMidi = Math.max(0, Math.round(midiTicks || 0));
        Tone.Transport.ticks = Math.round(safeMidi * toTransport);
        setTransportTicks(safeMidi); // UI stays in MIDI ticks space
        // Clear any active gate and add a brief grace window so the cursor stays put
        gateRef.current = { active: false, noteIndex: -1 };
        seekGraceUntilRef.current = performance.now() / 1000 + 0.30; // 300ms grace
        stopAll();

      }, [midiMeta.ppq]);

      const armGateForIndex = useCallback((idx) => {
        const n = notes[idx];
        if (!n) return false;

        const midiPPQ = midiMeta.ppq || 480;
        const transportPPQ = Tone.Transport.PPQ || 192;
        const toTransport = transportPPQ / midiPPQ;

        const mask = noteNameToMask(n.name);

        try {
          Tone.Transport.pause();
          Tone.Transport.ticks = Math.round((n.ticks || 0) * toTransport);
          stopAll();
        } catch { }

        gateRef.current = {
          active: true,
          noteIndex: idx,
          requiredTicks: n.durationTicks || 0,
          holdTicks: 0,
          mask: mask === null ? 0 : mask, // treat unmapped as open
          startTicks: n.ticks || 0,
          endTicks: (n.ticks || 0) + (n.durationTicks || 0),
          expectedMidi: n.midi ?? null,
          lastWallSec: performance.now() / 1000
        };

        // keep the UI cursor pinned
        handleSeekTicks(n.ticks || 0);
        return true;
      }, [notes, midiMeta.ppq, stopAll, handleSeekTicks]);


      // helper: find required mask at time t (monophonic expectation)
      const noteCursorRef = useRef(0);
      const getRequiredMaskAtTicks = useCallback((ticksNow) => {
        const arr = notes;
        if (!arr || !arr.length) return null;
        let i = noteCursorRef.current;
        // advance cursor if we've passed the current note (in ticks)
        while (i < arr.length && ((arr[i].ticks || 0) + (arr[i].durationTicks || 0)) <= ticksNow) i++;
        // rewind a little if user scrubbed back / restarted
        while (i > 0 && (arr[i].ticks || 0) > ticksNow) i--;
        noteCursorRef.current = i;
        const n = arr[i];
        if (!n) return null;
        const startT = (n.ticks || 0);
        const endT = startT + (n.durationTicks || 0);
        if (startT <= ticksNow && ticksNow < endT) {
          const m = noteNameToMask(n.name);
          if (m === null) return null;            // out-of-range -> ignore for scoring
          return {
            mask: m,
            startTicks: startT,
            endTicks: endT
          };
        }
        return null; // rest area
      }, [notes]);

      // Track last time the key mask changed (for transition grace)
      const lastKeyChangeSecRef = useRef(0);

      // Gate for Hold-to-Advance mode
      const gateRef = useRef({
        active: false, noteIndex: -1, requiredTicks: 0, holdTicks: 0,
        mask: 0, startTicks: 0, endTicks: 0, expectedMidi: null,
        lastWallSec: 0
      });
      // short grace after user seeks so the gate doesn't snap the cursor back
      const seekGraceUntilRef = useRef(0);

      useEffect(() => {
        const markChange = () => { lastKeyChangeSecRef.current = performance.now() / 1000; };
        const isTypingTarget = (el) => {
          if (!el) return false;
          const tag = (el.tagName || '').toLowerCase();
          return el.isContentEditable || ['input', 'textarea', 'select'].includes(tag);
        };
        const handleDown = (e) => {
          // Space = play/pause (use code for cross-browser reliability)
          if (e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar') {
            if (!isTypingTarget(e.target)) {
              e.preventDefault();         // stop the default button/scroll behavior
              e.stopPropagation();        // avoid double toggles from focused buttons
              togglePlay();
              return;
            }
          }
          const k = (e.key || '').toLowerCase();
          if (keyMap[k]) {
            e.preventDefault();
            setKeyMask((m) => {
              const next = (m | keyMap[k]);
              if (next !== m) markChange();
              return next;
            });
          }
        };

        const handleUp = (e) => {
          const k = e.key.toLowerCase();
          if (keyMap[k]) {
            e.preventDefault();
            setKeyMask((m) => {
              const next = (m & ~keyMap[k]);
              if (next !== m) markChange();
              return next;
            });
          }
        };
        window.addEventListener('keydown', handleDown);
        window.addEventListener('keyup', handleUp);
        return () => {
          window.removeEventListener('keydown', handleDown);
          window.removeEventListener('keyup', handleUp);
        };
      }, [keyMap]); // (replaces the previous key handlers)

      // Keep backing muted in Play-to-Advance, and when toggled ON mid-run
      useEffect(() => {
        setBackingMuted(waitMode);

        // If user turns on waitMode while already running, snap into gated state now.
        if (waitMode && running && notes.length) {
          // Kill any scheduled playback first, then gate.
          try { Tone.Transport.stop(); } catch { }
          clearPart();
          const midiPPQ = midiMeta.ppq || 480;
          const transportPPQ = Tone.Transport.PPQ || 192;
          const toMidi = midiPPQ / transportPPQ;
          const toTransport = transportPPQ / midiPPQ;

          // Current position in MIDI ticks
          let nowMidi = (readyRef.current ? Tone.Transport.ticks : 0) * toMidi;

          // Find the note we are currently inside
          let idx = -1;
          for (let i = 0; i < notes.length; i++) {
            const s = notes[i].ticks || 0;
            const e = s + (notes[i].durationTicks || 0);
            if (s <= nowMidi && nowMidi < e) { idx = i; break; }
          }

          if (idx >= 0) {
            const n = notes[idx];
            const mask = noteNameToMask(n.name);
            if (mask !== null) {
              try {
                // Pause and snap transport to the *start* of this note
                Tone.Transport.pause();
                Tone.Transport.ticks = Math.round((n.ticks || 0) * toTransport);
                stopAll();
              } catch { }
              // Arm the hold-to-advance gate immediately
              gateRef.current = {
                active: true,
                noteIndex: idx,
                requiredTicks: n.durationTicks || 0,
                holdTicks: 0,
                mask,
                startTicks: n.ticks || 0,
                endTicks: (n.ticks || 0) + (n.durationTicks || 0),
                expectedMidi: n.midi ?? null,
                lastWallSec: performance.now() / 1000
              };
              // Keep the UI cursor pinned too
              setTransportTicks(n.ticks || 0);
            }
          }
        }

        // If user turns waitMode OFF mid-run, re-schedule both lead and backing.
        if (!waitMode) {
          // Re-schedule current notes for audible playback again.
          const transportPPQ = Tone.Transport.PPQ || 192;
          const midiPPQ = midiMeta.ppq || 480;
          const scaleToTransport = transportPPQ / midiPPQ;
          // rebuild backing for current track selection
          const t0Ticks = notes.length ? (notes[0].ticks || 0) : 0;
          const t0Time = notes.length ? notes[0].time : 0;
          const backingRaw = midiMeta.tracks
            .filter((_, i) => i !== (trackIndex || 0))
            .flatMap(tr => tr.notes || []);
          const backingNotes = backingRaw.map(b => ({
            ...b,
            time: Math.max(0, b.time - t0Time),
            ticks: Math.max(0, (b.ticks || 0) - t0Ticks)
          }));
          scheduleLeadPart(notes, scaleToTransport);
          scheduleBackingPart(backingNotes, scaleToTransport);

          if (running && gateRef.current.active) {
            gateRef.current = { active: false, noteIndex: gateRef.current.noteIndex };
            try { Tone.Transport.start('+0.02'); } catch { }
          }
        }
      }, [waitMode, running, notes, midiMeta.ppq, readyRef, stopAll, setBackingMuted, scheduleLeadPart, scheduleBackingPart, clearLeadPart, clearBackingPart, trackIndex]);


      useEffect(() => {
        let raf = null;
        let lastMidiTicks = 0; // we keep all UI/scoring in MIDI ticks
        const tick = () => {
          const midiPPQ = midiMeta.ppq || 480;
          const transportPPQ = Tone.Transport.PPQ || 192;
          const toMidi = midiPPQ / transportPPQ;
          let nowMidi = readyRef.current ? Tone.Transport.ticks * toMidi : 0;

          // -------------------------
          // Hold-to-Advance gate logic
          // -------------------------
          if (running && waitMode && notes.length) {
            const gate = gateRef.current;
            const secPerTick = 60 / (midiPPQ * bpm);
            const toTransport = transportPPQ / midiPPQ;

            if (gate.active) {
              // accumulate "correctly held" time while transport is paused at note start
              const wallNow = performance.now() / 1000;
              const dtSec = Math.max(0, wallNow - (gate.lastWallSec || wallNow));
              gate.lastWallSec = wallNow;

              // allow mic based or key-based gating
              let ok = false;
              if (micEnabled && Number.isFinite(gate.expectedMidi)) {
                const tol = 35; // cents
                const targetFreq = midiToFreq(gate.expectedMidi);
                if (window.__lastMicNoteWritten?.midi) {
                  // Compare written mic midi against written expected midi
                  ok = (window.__lastMicNoteWritten.midi === gate.expectedMidi);
                }
                if (!ok && window.__lastMicNoteWritten?.freq && !expertMode) {
                  const c = centsDiff(window.__lastMicNoteWritten.freq, targetFreq);
                  ok = Math.abs(c) <= tol;
                }
              } else {
                const withinChangeGrace = (wallNow - lastKeyChangeSecRef.current) < 0.060;
                const heldMask = pressedMaskRef.current;
                ok = (heldMask === gate.mask) || withinChangeGrace;
              }
              if (ok) gate.holdTicks += dtSec / secPerTick;

              // Keep cursor/UI pinned to the start of this note.
              nowMidi = gate.startTicks;

              // Completed required duration? Jump to end of note and resume.
              if (gate.holdTicks >= (gate.requiredTicks || 0)) {
                // In wait mode, a note is considered correct once the player advances.
                const prevIdx = gate.noteIndex;
                if (prevIdx >= 0) {
                  upsertRunLog(prevIdx, {
                    result: 'hit',
                    source: micEnabled ? 'mic' : 'keys',
                    timingErrorMs: 0
                  });
                }

                // Advance to the *next* playable note and re-arm the gate (stay paused)
                let nextIdx = gate.noteIndex + 1;
                // Skip any notes that don't map to a valve combo, if any
                while (nextIdx < notes.length && noteNameToMask(notes[nextIdx].name) === null) nextIdx++;

                if (!armGateForIndex(nextIdx)) {
                  // No next note — end of piece
                  try { Tone.Transport.stop(); } catch { }
                  setRunning(false);
                  gateRef.current = { active: false, noteIndex: -1 };
                }
                // Important: do NOT call Transport.start() here, else it plays the entire song.
              }
            } else {
              // If we're currently inside a note, pause at its start and start gating
              let idx = -1;
              for (let i = 0; i < notes.length; i++) {
                const s = notes[i].ticks || 0;
                const e = s + (notes[i].durationTicks || 0);
                if (s <= nowMidi && nowMidi < e) { idx = i; break; }
              }
              const okToGate = (performance.now() / 1000) > (seekGraceUntilRef.current || 0);
              if (idx >= 0 && okToGate) {
                const n = notes[idx];
                const mask = noteNameToMask(n.name);
                if (mask !== null) {
                  try {
                    Tone.Transport.pause();
                    Tone.Transport.ticks = Math.round((n.ticks || 0) * (toTransport));
                    stopAll();
                  } catch { }
                  gateRef.current = {
                    active: true,
                    noteIndex: idx,
                    requiredTicks: n.durationTicks || 0,
                    holdTicks: 0,
                    mask,
                    startTicks: n.ticks || 0,
                    endTicks: (n.ticks || 0) + (n.durationTicks || 0),
                    expectedMidi: n.midi ?? null,
                    lastWallSec: performance.now() / 1000
                  };
                  nowMidi = n.ticks || 0;
                }
              }
            }
          }
          setTransportTicks(nowMidi);

          const dtTicks = Math.max(0, nowMidi - lastMidiTicks);
          lastMidiTicks = nowMidi;
          if (running && dtTicks > 0.1) { // tiny guard
            const ppq = midiMeta.ppq || 480;               // MIDI PPQ
            const secPerTick = 60 / (ppq * bpm);           // convert MIDI ticks → seconds at current BPM
            const dtSec = dtTicks * secPerTick;

            const reqInfo = getRequiredMaskAtTicks(nowMidi);
            if (reqInfo) {
              const { mask: reqMask, startTicks } = reqInfo;
              const held = pressedMaskRef.current;
              const ok = (held === reqMask);

              // Grace windows
              const changeGraceSec = 0.060;
              const startGraceSec = 0.080;
              const wallNowSec = performance.now() / 1000;
              const withinChangeGrace = (wallNowSec - lastKeyChangeSecRef.current) < changeGraceSec;
              const withinStartGrace = ((nowMidi - startTicks) * secPerTick) < startGraceSec;

              const next = { ...statsRef.current };
              if (ok) {
                next.hitTime += dtSec;
              } else if (withinChangeGrace || withinStartGrace) {
                // don't penalize transition/onset
              } else {
                next.missTime += dtSec;
              }
              statsRef.current = next;
              setStats(next);
            }
          }
          raf = requestAnimationFrame(tick);
        };
        // seed last as MIDI ticks
        if (readyRef.current) {
          const midiPPQ = midiMeta.ppq || 480;
          const transportPPQ = Tone.Transport.PPQ || 192;
          lastMidiTicks = Tone.Transport.ticks * (midiPPQ / transportPPQ);
        } else {
          lastMidiTicks = 0;
        }
        raf = requestAnimationFrame(tick);
        return () => { if (raf) cancelAnimationFrame(raf); };
      }, [running, waitMode, readyRef, getRequiredMaskAtTicks, bpm, midiMeta.ppq, notes]);

      // Song title
      const songTitle = midiMeta.title || 'Trumpet Trainer';

      // Track names
      const trackNames = (midiMeta.tracks || []).map(t => t.name);

      // Current container sizes
      const scoreHeight = isMobile ? 160 : 220;
      const highwayHeight = 320;

      const expectedMidiNow = React.useMemo(() => {
        const t = transportTicks || 0;
        for (let i = 0; i < notes.length; i++) {
          const s = notes[i].ticks || 0;
          const e = s + (notes[i].durationTicks || 0);
          if (s <= t && t < e) return (Number.isFinite(notes[i].midi) ? notes[i].midi : noteNameToMidi(notes[i].name));
        }
        return null;
      }, [transportTicks, notes]);

      const scoreOnly = showScore && !showHighway;

      const pulseAmpRef = useRef(0);
      useEffect(() => {
        let raf;
        const drive = () => {
          // decay spikes
          pulseAmpRef.current *= 0.92;
          // quarter-note phase (ppq-based so tempo changes are fine)
          const ppq = midiMeta.ppq || 480;
          const ticks = readyRef.current ? Tone.Transport.ticks : 0;
          const p = (ticks % ppq) / ppq;                 // 0..1
          const tri = 1 - Math.abs(2 * p - 1);             // triangle
          const pulse = Math.pow(tri, 2);                // eased
          const host = highwayPulseRef.current;
          if (host) {
            host.style.setProperty('--pulse', String(pulse));
            host.style.setProperty('--pulseAmp', String(0.45 + pulseAmpRef.current));
          }
          raf = requestAnimationFrame(drive);
        };
        raf = requestAnimationFrame(drive);
        return () => cancelAnimationFrame(raf);
      }, [midiMeta.ppq, readyRef]);


      return (
        <div className="h-full w-full flex flex-col min-h-0">
          {/* Top bar */}
          <header className="w-full flex items-center gap-3 px-3 py-2"
            style={{
              background: 'linear-gradient(180deg, rgba(9,14,28,.70), rgba(9,14,28,.25))',
              borderBottom: '1px solid rgba(255,255,255,.06)', backdropFilter: 'blur(6px)'
            }}>
            <button className="p-2 rounded hover:bg-slate-700" onClick={() => setMenuOpen(true)} title="Settings">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-slate-100" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M4 6h16M4 12h16M4 18h16" />
              </svg>
            </button>
            <div className="text-sm text-slate-300">Trumpet Trainer</div>
            <div className="mx-2 w-px h-6 bg-slate-700/80" />
            <div className="font-semibold truncate">{songTitle}</div>
            <div className="ml-auto flex items-center gap-2">
              {/* Fullscreen toggle (mobile & desktop) */}
              <button
                className="p-2 rounded hover:bg-slate-700 text-lg"
                title={isFullscreen ? "Exit fullscreen" : "Enter fullscreen"}
                onClick={() => {
                  if (!document.fullscreenElement) { document.documentElement.requestFullscreen?.(); }
                  else { document.exitFullscreen?.(); }
                }}
              >⛶</button>
              {/* Hide valve key legends on small screens */}
              <div className="text-xs opacity-90 items-center gap-2 hidden sm:flex">
                <span className="text-slate-300">Valves:</span>
                <span className="kbd" style={{ borderColor: 'rgba(255,255,255,.25)' }}>{displayKeyForValve(keyMap, VALVE1) || 'A'}</span>
                <span className="kbd" style={{ borderColor: 'rgba(255,255,255,.25)' }}>{displayKeyForValve(keyMap, VALVE2) || 'S'}</span>
                <span className="kbd" style={{ borderColor: 'rgba(255,255,255,.25)' }}>{displayKeyForValve(keyMap, VALVE3) || 'D'}</span>
              </div>
            </div>
          </header>

          {/* Score area (toggleable) */}
          {showScore && (
            <section className={scoreOnly ? "flex-1 px-3 pt-3 min-h-0" : "px-3 pt-3"}>
              <div
                ref={scoreOnly ? scoreMeasureRef : null}
                className={scoreOnly ? "w-full h-full min-h-0" : "w-full"}
                style={scoreOnly ? undefined : { height: scoreHeight + 'px' }}
              >
                <ScoreDisplay
                  notes={notes}
                  bpm={bpm}
                  timeSig={timeSig}
                  ppq={midiMeta.ppq || 480}
                  showNoteNames={showNoteNames}
                  currentTicks={transportTicks}
                  running={running}
                  width={
                    scoreOnly
                      ? Math.max(1, (scoreSize.w || (document.body.clientWidth - 24)))
                      : (document.body.clientWidth - 24)
                  }
                  height={
                    scoreOnly
                      ? Math.max(1, (scoreSize.h || scoreHeight))
                      : scoreHeight
                  }
                  measuresPerRow={2}
                  onSeekTicks={handleSeekTicks}
                  ref={overlayApiRef}
                  lastTake={lastTake}
                  showLastTake={showLastTake}
                  overlayOpacity={overlayOpacity}
                  micEnabled={micEnabled}
                  micNote={micNote}
                  expertMode={expertMode}
                  toleranceCents={35}
                />
              </div>
            </section>
          )}

          {/* Highway */}
          {showHighway ? (
            <section id="highway" className="flex-1 px-3 py-3 min-h-0">
              <div className="w-full h-full min-h-0">
                <div
                  ref={highwayMeasureRef}
                  className="grid-drift relative w-full h-full min-h-[120px] md:min-h-0 overflow-hidden"
                  style={{
                    '--beat': (60 / (bpm || 120)) + 's',
                    '--cell': Math.round(Math.max(28, Math.min(64, 52 - (bpm - 120) * 0.10))) + 'px'
                  }}
                >
                  <NoteHighway
                    laneEvents={laneEvents}
                    keyStateMask={pressedMask}
                    width={Math.max(1, canvasSize.w || highwayMeasureRef.current?.clientWidth || 0)}
                    height={Math.max(1, canvasSize.h || highwayMeasureRef.current?.clientHeight || 0)}
                    lookahead={lookahead}
                    onHitJudgement={onHitJudgement}
                    running={running}
                    currentTicks={transportTicks}
                    bpm={bpm}
                    ppq={midiMeta.ppq || 480}
                    onTouchMaskChange={setTouchMask}
                    micNote={micNote}
                    micEnabled={micEnabled}
                    tunerTargetMidi={expectedMidiNow}
                    tunerToleranceCents={15}

                  />
                  <div className="hitline" style={{ top: (canvasSize.h * 0.88) + 'px' }} />
                  <div className="absolute left-0 right-0 bottom-1 flex justify-center gap-12 text-xs text-slate-300">
                    <div style={{ color: 'var(--laneA)' }}>Valve 1</div>
                    <div style={{ color: 'var(--laneB)' }}>Valve 2</div>
                    <div style={{ color: 'var(--laneC)' }}>Valve 3</div>
                  </div>
                </div>
              </div>
            </section>
          ) : (
            // Show the mobile placeholder only if the user hasn't hidden the highway
            showHighwaySetting && (
              <section className="px-3 py-3 sm:hidden">
                <div className="w-full rounded-md border border-slate-700/60 bg-slate-900/40 p-4 text-center text-slate-300">
                  Game will start when you press <span className="font-semibold">Play</span>.
                  <div className="text-xs text-slate-400 mt-1">
                    Choose a song and pick a track first{waitMode ? ', or turn off Play-to-Advance.' : '.'}
                  </div>
                </div>
              </section>
            )
          )}

          {/* Bottom controls */}
          <footer className="px-3 pb-3">
            <Controls
              isLoaded={!!notes.length}
              running={running}
              onPlayPause={togglePlay}
              onStop={stopTransport}
              onGoStart={goToStart}
              bpm={bpm}
              onBpm={setBpm}
              onFile={onFile}
              trackNames={trackNames}
              trackIndex={trackIndex}
              onTrackIndex={setTrackIndex}
              stats={stats}
              micNote={micNote}
              micEnabled={micEnabled}
              waitMode={waitMode}
              onWaitMode={setWaitMode}
              transposeSemis={transposeSemis}
              onTransposeSemis={setTransposeSemis}
              isMobile={isMobile}
              onOpenPicker={() => setPickerOpen(true)}
            />
          </footer>

          {/* Settings menu */}
          <MenuPane
            open={menuOpen}
            onClose={() => setMenuOpen(false)}
            keyMap={keyMap}
            setKeyMap={setKeyMap}
            lookahead={lookahead}
            setLookahead={setLookahead}
            micEnabled={micEnabled}
            setMicEnabled={setMicEnabled}
            expertMode={expertMode}
            setExpertMode={setExpertMode}
            transposeSemis={transposeSemis}
            setTransposeSemis={setTransposeSemis}
            showScore={showScore}
            setShowScore={setShowScore}
            showHighway={showHighwaySetting}
            setShowHighway={setShowHighway}
            showNoteNames={showNoteNames}
            setShowNoteNames={setShowNoteNames}
            showLastTake={showLastTake}
            setShowLastTake={setShowLastTake}
            overlayOpacity={overlayOpacity}
            setOverlayOpacity={setOverlayOpacity}
            onResetSettings={resetSettings}
          />

          <SongPickerModal
            open={pickerOpen}
            onClose={() => setPickerOpen(false)}
            onPickUrl={onPickUrl} onUploadFile={onFile} />
        </div>
      );
    }

    document.addEventListener('keydown', (e) => {
      const k = e.key?.toLowerCase?.();
      if (k === 'a' || k === 's' || k === 'd') { try { window.__pulseAmp && (window.__pulseAmp.value = 1); } catch { } }
    }, { passive: true });

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>

</html>